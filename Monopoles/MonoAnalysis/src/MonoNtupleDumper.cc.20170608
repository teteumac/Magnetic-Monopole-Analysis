// -*- C++ -*-
//
// Package:    MonoNtupleDumper
// Class:      MonoNtupleDumper
// 
/**\class MonoNtupleDumper MonoNtupleDumper.cc Monopoles/MonoNtupleDumper/src/MonoNtupleDumper.cc

 Description: [one line class summary]

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Christopher Cowden
//         Created:  Tue Feb  7 16:21:08 CST 2012
// $Id: MonoNtupleDumper.cc,v 1.7 2013/06/13 21:45:27 cowden Exp $
//
//

// system include files
#include <vector>
#include <string>
#include <set>
#include <memory>
#include <algorithm>
#include <sstream>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/Framework/interface/ConsumesCollector.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"

// math
#include "DataFormats/Math/interface/deltaR.h"

// geometry
#include "Geometry/CommonDetUnit/interface/GlobalTrackingGeometry.h"

// data formats
#include "DataFormats/EcalRecHit/interface/EcalRecHit.h"
#include "DataFormats/EcalRecHit/interface/EcalRecHitCollections.h"
#include "DataFormats/Common/interface/SortedCollection.h"
#include "DataFormats/Common/interface/ValueMap.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/Common/interface/Handle.h"
#include "FWCore/Common/interface/TriggerNames.h"

#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "DataFormats/EgammaCandidates/interface/Photon.h"
#include "DataFormats/EgammaCandidates/interface/Electron.h"
#include "DataFormats/EgammaCandidates/interface/GsfElectron.h"
#include "DataFormats/EgammaReco/interface/BasicCluster.h"
#include "DataFormats/EgammaReco/interface/BasicClusterFwd.h"
#include "DataFormats/METReco/interface/PFMET.h"

// vertex
#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"

// Ecal includes
#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
#include "Geometry/Records/interface/CaloGeometryRecord.h"
#include "Geometry/Records/interface/CaloTopologyRecord.h"
#include "Geometry/CaloGeometry/interface/CaloSubdetectorGeometry.h"
#include "DataFormats/EcalDetId/interface/EcalSubdetector.h"
#include "DataFormats/EcalDetId/interface/EBDetId.h"
#include "RecoEcal/EgammaCoreTools/interface/EcalClusterTools.h"
#include "RecoEgamma/EgammaIsolationAlgos/interface/EgammaHcalIsolation.h"

// Hcal includes
#include "DataFormats/HcalRecHit/interface/HcalRecHitCollections.h"

// trigger includes
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"

// Monopole analysis includes
//#include "Monopoles/MonoAlgorithms/interface/NPVHelper.h"
#include "Monopoles/MonoAlgorithms/interface/MonoEcalObs0.h"
#include "Monopoles/MonoAlgorithms/interface/ClustCategorizer.h"
#include "Monopoles/MonoAlgorithms/interface/MonoTrackMatcher.h"
#include "Monopoles/MonoAlgorithms/interface/MonoGenTrackExtrapolator.h"
#include "Monopoles/TrackCombiner/interface/MplTracker.h"

//Track + Tracker
#include "Geometry/TrackerGeometryBuilder/interface/TrackerGeometry.h"
#include "Geometry/Records/interface/TrackerDigiGeometryRecord.h"
#include "Geometry/TrackerGeometryBuilder/interface/StripGeomDetUnit.h"
#include "Geometry/TrackerGeometryBuilder/interface/PixelGeomDetUnit.h"
#include "Geometry/Records/interface/GlobalTrackingGeometryRecord.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/TrackReco/interface/TrackFwd.h"
#include "TrackingTools/PatternTools/interface/Trajectory.h"
#include "TrackingTools/PatternTools/interface/TrajTrackAssociation.h"

//TrackerRecHit2D
#include "DataFormats/TrackerRecHit2D/interface/SiStripRecHit2D.h"
#include "DataFormats/TrackerRecHit2D/interface/SiStripMatchedRecHit2D.h"
#include "DataFormats/TrackerRecHit2D/interface/SiPixelRecHit.h"
#include "DataFormats/TrackerRecHit2D/interface/ProjectedSiStripRecHit2D.h"
#include "DataFormats/TrackerRecHit2D/interface/SiStripRecHit1D.h"
#include "RecoTracker/DeDx/interface/DeDxTools.h"
#include "DataFormats/CaloRecHit/interface/CaloCluster.h"

// ROOT includes
#include "TFile.h"
#include "TTree.h"
#include "TBranch.h"
#include "TH2D.h"
#include "TH1D.h"
#include "TF1.h"
#include "TF2.h"
#include "TMath.h"
#include "TGraphErrors.h"
#include "TFitResult.h"
#include "TVirtualFitter.h"

#include "DataFormats/GeometryCommonDetAlgo/interface/ErrorFrameTransformer.h"

using namespace std;
using namespace edm;
typedef std::vector<Trajectory> TrajectoryCollection;

//#define DEBUG

//
// class declaration
//
//namespace edm { class ConsumesCollector; }

class MonoNtupleDumper : public edm::EDAnalyzer {
  
  typedef std::vector<reco::BasicCluster> BasicClusterCollection;
  typedef std::vector<reco::Photon> PhotonCollection;
  //typedef std::vector<reco::Electron> ElectronCollection;
  typedef std::vector<reco::GsfElectron> ElectronCollection;
  typedef reco::GsfElectron Electron;
  typedef reco::Photon Photon;
  
public:
  explicit MonoNtupleDumper(const edm::ParameterSet&);
  ~MonoNtupleDumper();
  
  static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);
  
private:
  virtual void Init(const edm::EventSetup&) ;

  virtual void beginJob() ;
  virtual void analyze(const edm::Event&, const edm::EventSetup&);
  virtual void endJob() ;
  
  virtual void beginRun(edm::Run const&, edm::EventSetup const&);
  virtual void endRun(edm::Run const&, edm::EventSetup const&);
  virtual void beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&);
  virtual void endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&);

  virtual void AddMoreTracks(vector<int> &Group);
  virtual int  AddPoints(const reco::Track &Track);
  virtual void RemovePoints(int n);
  virtual void FitXY(vector<int> &Group);
  virtual void FitRZ(bool Debug=false);
  virtual void AverageIso(vector<int> &Group);
  virtual void Save(vector<int> &Group);
  virtual void Clear();

  // clear tree variables
  void clear();
  
  void rematch(); 
  
  // ----------member data ---------------------------
  
  std::string m_output;
  TFile *m_outputFile;
  
  // HLTConfigProvider
  HLTConfigProvider m_hltConfig;
  
  // input tags
  edm::EDGetTokenT< edm::TriggerResults > m_hltResults;
  edm::EDGetTokenT< reco::VertexCollection > m_PVTag;
  edm::EDGetTokenT< EBRecHitCollection > m_TagEcalEB_RecHits;
  edm::EDGetTokenT< EERecHitCollection > m_TagEcalEE_RecHits;
  edm::EDGetTokenT< HBHERecHitCollection > m_TagHcalHBHE_RecHits;
  edm::EDGetTokenT< reco::TrackCollection > m_TrackTag;
  edm::EDGetTokenT<std::vector<Trajectory> > m_TrajectoryTag;
  edm::EDGetTokenT<TrajTrackAssociationCollection> m_assoMapTag;
  edm::EDGetTokenT< reco::PFJetCollection > m_Tag_Jets;
  edm::EDGetTokenT< PhotonCollection > m_Tag_Photons;
  edm::EDGetTokenT< ElectronCollection > m_Tag_Electrons;
  edm::EDGetTokenT< std::vector<reco::PFMET> > m_Tag_MET;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_bClusters;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_cClusters;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_combClusters;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_eeClean;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_eeUnclean;
  edm::EDGetTokenT< reco::BasicClusterCollection > m_Tag_eeComb;

  bool m_isData;

  // Monopole Ecal Observables
  Mono::MonoEcalObs0 m_ecalObs;
  
  //Tracker
  edm::Handle<reco::TrackCollection> _hTracks;
  edm::Handle<TrajectoryCollection> _hTrajectories;
  edm::Handle<TrajTrackAssociationCollection> _hTrajTrackAssociations; 
  edm::ESHandle<GlobalTrackingGeometry> _TrackingGeom;
  map<uint, float> _NormMap;
  set<int> _Used;
  MplTracker *_Tracker;
  float _PhiCut, _Chi2Cut, _PtCut, _DeDxCut, _DefaultError, _ErrorFudge;

  //TLinearFitter *_RZFitter;
  TF1 *_RZFunc;
  TF1 *_XYFunc;
  //UnbinnedLikelihoodFit _DeDxFitter;
  //TF1 *_DeDxFunc;

  float _XYPar[3], _XYErr[3], _RZPar[3], _RZErr[3];
  float _Chi2XY, _Chi2RZ;
  int _Ndof;
  float _Iso;

  vector<float> _vXYPar0, _vXYPar1, _vXYPar2;
  vector<float> _vXYErr0, _vXYErr1, _vXYErr2;
  vector<float> _vRZPar0, _vRZPar1, _vRZPar2;
  vector<float> _vRZErr0, _vRZErr1, _vRZErr2;
  vector<float> _vChi2XY, _vChi2RZ, _vNdof, _vIso;
  vector<int> _vHits, _vSatHits, _vSubHits, _vSatSubHits;
  vector<string> _vGroup;
  vector<int> _clustMatchEB; // match to ecal cluster
  vector<int> _clustMatchEBClean; // match to ecal cluster
  vector<int> _clustMatchEBUnclean; // match to ecal cluster
  vector<int> _clustMatchEE; // match to ecal cluster
  vector<int> _clustMatchEEClean; // match to ecal cluster
  vector<int> _clustMatchEEUnclean; // match to ecal cluster
  vector<double> _clustDistEB; // distance to ecal cluster
  vector<double> _clustDistEBClean; // distance to ecal cluster
  vector<double> _clustDistEBUnclean; // distance to ecal cluster
  vector<double> _clustDistEE; // distance to ecal cluster
  vector<double> _clustDistEEClean; // distance to ecal cluster
  vector<double> _clustDistEEUnclean; // distance to ecal cluster
  vector<int> _vTHTrack, _vTHStrips, _vTHSatStrips;
  vector<float> _vTHX, _vTHY, _vTHZ, _vTHErrX, _vTHErrY, _vTHErrZ;
  //
  vector<GlobalPoint> _Points;
  vector<GlobalError> _Errors;
  vector<float>       _Charges;
  vector<float>       _HighHits;
  vector<float>       _SumHits;

  // TFileService
  //edm::Service<TFileService> m_fs;
  
  // map cluster category (lengthxwidth thing) to a histogram
  // showing the average energy or time  in each cell
  //TFileDirectory *m_avgDir;
  std::map<Mono::ClustCategorizer,TH2D *> m_clustEMap;
  std::map<Mono::ClustCategorizer,TH2D *> m_clustTMap;
  std::map<Mono::ClustCategorizer,unsigned> m_clustCatCount;
  
  std::vector<double> m_betas;
  std::vector<double> m_betaTs;
  
  TTree * m_tree;
  
  bool _ClustHitOutput;
  bool _EleJetPhoOutput;
  bool _TrackHitOutput;

  // Event information
  unsigned m_run;
  unsigned m_lumi;
  unsigned m_event;
  unsigned m_NPV;
  bool m_isFirstEvent;
  unsigned m_NTrigs;
  std::vector<bool> m_trigResults;
  std::vector<std::string> m_trigNames;
  
  // Ecal Observable information
  unsigned m_nClusters;
  std::vector<double> m_clust_E;
  std::vector<double> m_clust_eta;
  std::vector<double> m_clust_phi;
  std::vector<double> m_clust_L;
  std::vector<double> m_clust_W;
  std::vector<double> m_clust_N;
  std::vector<double> m_clust_sigEta;
  std::vector<double> m_clust_sigPhi;
  std::vector<double> m_clust_meanEta;
  std::vector<double> m_clust_meanPhi;
  std::vector<double> m_clust_skewEta;
  std::vector<double> m_clust_skewPhi;
  std::vector<double> m_clust_seedFrac;
  std::vector<double> m_clust_firstFrac;
  std::vector<double> m_clust_secondFrac;
  std::vector<double> m_clust_thirdFrac;
  std::vector<double> m_clust_phiStripFrac;
  std::vector<double> m_clust_matchDR;
  std::vector<double> m_clust_tagged;
  std::vector<double> m_clust_matchPID;
  std::vector<double> m_clust_matchTime;
  std::vector<double> m_clust_matchPt;
  std::vector<double> m_clust_hsE;
  std::vector<double> m_clust_hsTime;
  std::vector<int>    m_clust_hsInSeed;
  std::vector<int>    m_clust_hsWeird;
  std::vector<int>    m_clust_hsDiWeird;
  // Treat these arrays as 3D arrays
  // There is space for 15 clusters of 100 total elements in each cluster
  // One must use m_nClusters, m_clust_L, and m_clust_W when unpacking
  // the cluster from the TTree.
  static const unsigned WS = 100;
  static const unsigned SS = 15*100;
  double m_clust_Ecells[1500]; 
  double m_clust_Tcells[1500]; 
  
  // Ecal hybrid clusters
  unsigned m_nClusterEgamma;
  std::vector<double> m_egClust_E;
  std::vector<double> m_egClust_size;
  std::vector<double> m_egClust_eta;
  std::vector<double> m_egClust_phi;
  std::vector<double> m_egClust_frac51;
  std::vector<double> m_egClust_frac15;
  std::vector<double> m_egClust_e55;
  std::vector<double> m_egClust_eMax;
  std::vector<double> m_egClust_matchDR;
  std::vector<double> m_egClust_tagged;
  std::vector<double> m_egClust_matchPID;
  std::vector<double> m_egClust_hcalIso;
  
  // Ecal hybrid clusters (cleaned collection)
  unsigned m_nCleanEgamma;
  std::vector<double> m_egClean_E;
  std::vector<double> m_egClean_size;
  std::vector<double> m_egClean_eta;
  std::vector<double> m_egClean_phi;
  std::vector<double> m_egClean_frac51;
  std::vector<double> m_egClean_frac15;
  std::vector<double> m_egClean_e55;
  std::vector<double> m_egClean_eMax;
  std::vector<double> m_egClean_matchDR;
  std::vector<double> m_egClean_tagged;
  std::vector<double> m_egClean_matchPID;
  std::vector<double> m_egClean_hcalIso;
  
  // Ecal hybrid clusters (combined collection)
  unsigned m_nCombEgamma;
  std::vector<double> m_egComb_E;
  std::vector<double> m_egComb_size;
  std::vector<double> m_egComb_eta;
  std::vector<double> m_egComb_phi;
  std::vector<double> m_egComb_frac51;
  std::vector<double> m_egComb_frac15;
  std::vector<double> m_egComb_e55;
  std::vector<double> m_egComb_eMax;
  std::vector<double> m_egComb_e25Right;
  std::vector<double> m_egComb_e25Left;
  std::vector<double> m_egComb_matchDR;
  std::vector<double> m_egComb_tagged;
  std::vector<double> m_egComb_matchPID;
  std::vector<double> m_egComb_hcalIso;
  
  // EE clusters (cleaned)
  unsigned m_nCleanEE;
  std::vector<double> m_eeClean_E;
  std::vector<double> m_eeClean_size;
  std::vector<double> m_eeClean_eta;
  std::vector<double> m_eeClean_phi;
  std::vector<double> m_eeClean_frac51;
  std::vector<double> m_eeClean_frac15;
  std::vector<double> m_eeClean_e55;
  std::vector<double> m_eeClean_eMax;
  std::vector<double> m_eeClean_matchDR;
  std::vector<double> m_eeClean_tagged;
  std::vector<double> m_eeClean_matchPID;
  std::vector<double> m_eeClean_hcalIso;
  
  // EE clusters (uncleanOnly)
  unsigned m_nUncleanEE;
  std::vector<double> m_eeUnclean_E;
  std::vector<double> m_eeUnclean_size;
  std::vector<double> m_eeUnclean_eta;
  std::vector<double> m_eeUnclean_phi;
  std::vector<double> m_eeUnclean_frac51;
  std::vector<double> m_eeUnclean_frac15;
  std::vector<double> m_eeUnclean_e55;
  std::vector<double> m_eeUnclean_eMax;
  std::vector<double> m_eeUnclean_matchDR;
  std::vector<double> m_eeUnclean_tagged;
  std::vector<double> m_eeUnclean_matchPID;
  std::vector<double> m_eeUnclean_hcalIso;
  
  // EE clusters (combined)
  unsigned m_nCombEE;
  std::vector<double> m_eeComb_E;
  std::vector<double> m_eeComb_size;
  std::vector<double> m_eeComb_eta;
  std::vector<double> m_eeComb_phi;
  std::vector<double> m_eeComb_frac51;
  std::vector<double> m_eeComb_frac15;
  std::vector<double> m_eeComb_e55;
  std::vector<double> m_eeComb_eMax;
  std::vector<double> m_eeComb_e25Left;
  std::vector<double> m_eeComb_e25Right;
  std::vector<double> m_eeComb_matchDR;
  std::vector<double> m_eeComb_tagged;
  std::vector<double> m_eeComb_matchPID;
  std::vector<double> m_eeComb_hcalIso;
  
  // Ecal RecHits
  std::vector<double> m_ehit_eta;
  std::vector<double> m_ehit_phi;
  std::vector<double> m_ehit_time;
  std::vector<double> m_ehit_energy;
  std::vector<double> m_ehit_otEnergy;
  std::vector<double> m_ehit_flag;
  std::vector<double> m_ehit_kWeird;
  std::vector<double> m_ehit_kDiWeird;
  
  // Jet information
  unsigned m_jet_N;
  std::vector<double> m_jet_E;
  std::vector<double> m_jet_p;
  std::vector<double> m_jet_pt;
  std::vector<double> m_jet_px;
  std::vector<double> m_jet_py;
  std::vector<double> m_jet_pz;
  std::vector<double> m_jet_eta;
  std::vector<double> m_jet_phi;
  std::vector<double> m_jet_matchDR;
  std::vector<int>  m_jet_tagged;
  std::vector<int>  m_jet_matchPID;
  
  // Photon information
  unsigned m_pho_N;
  std::vector<double> m_pho_E;
  std::vector<double> m_pho_p;
  std::vector<double> m_pho_pt;
  std::vector<double> m_pho_px;
  std::vector<double> m_pho_py;
  std::vector<double> m_pho_pz;
  std::vector<double> m_pho_eta;
  std::vector<double> m_pho_phi;
  std::vector<double> m_pho_matchDR;
  std::vector<int>  m_pho_tagged;
  std::vector<int>  m_pho_matchPID;
  
  // Electron information
  unsigned m_ele_N;
  std::vector<double> m_ele_E;
  std::vector<double> m_ele_p;
  std::vector<double> m_ele_pt;
  std::vector<double> m_ele_px;
  std::vector<double> m_ele_py;
  std::vector<double> m_ele_pz;
  std::vector<double> m_ele_eta;
  std::vector<double> m_ele_phi;
  std::vector<double> m_ele_matchDR;
  std::vector<int>  m_ele_tagged;
  std::vector<int>  m_ele_matchPID;
  
  // MET information
  double m_mpt;
  double m_mpPhi;
  
  // Generator level branches
  double m_mono_p;
  double m_mono_eta;
  double m_mono_phi;
  double m_mono_m;
  double m_mono_px;
  double m_mono_py;
  double m_mono_pz;
  double m_mono_x;
  double m_mono_y;
  double m_mono_z;
  
  double m_monoExp_eta;
  double m_monoExp_phi;
  double m_monoExpEE_eta;
  double m_monoExpEE_phi;
  
  double m_amon_p;
  double m_amon_eta;
  double m_amon_phi;
  double m_amon_m;
  double m_amon_px;
  double m_amon_py;
  double m_amon_pz;
  double m_amon_x;
  double m_amon_y;
  double m_amon_z;
  
  double m_amonExp_eta;
  double m_amonExp_phi;
  double m_amonExpEE_eta;
  double m_amonExpEE_phi;
  
  ////////////////////////////////////////
  // Branches to hold the combined monopole objects
  unsigned m_nCandidates;
  std::vector<double> m_candDist;
  std::vector<double> m_candSubHits;
  std::vector<double> m_candSatSubHits;
  std::vector<double> m_canddEdXSig;
  std::vector<double> m_candTIso;
  std::vector<double> m_candSeedFrac;
  std::vector<double> m_candf15;
  std::vector<double> m_candE55;
  std::vector<double> m_candHIso;
  std::vector<double> m_candXYPar0;
  std::vector<double> m_candXYPar1;
  std::vector<double> m_candXYPar2;
  std::vector<double> m_candRZPar0;
  std::vector<double> m_candRZPar1;
  std::vector<double> m_candRZPar2;
  std::vector<double> m_candEta;
  std::vector<double> m_candPhi;
  
};

//
// constants, enums and typedefs
//

namespace chow {
  
  double mag ( double x, double y) {
    return sqrt( x*x + y*y );
  }
  
  double mag ( double x, double y, double z){
    return sqrt( x*x + y*y + z*z );
  }
  
}


//
// static data member definitions
//

//
// constructors and destructor
//
MonoNtupleDumper::MonoNtupleDumper(const edm::ParameterSet& iConfig)
  :m_output(iConfig.getParameter<std::string>("Output"))
  ,m_hltResults( consumes< edm::TriggerResults >( iConfig.getParameter< edm::InputTag >( "TriggerResults" ) ) )
  ,m_PVTag( consumes< reco::VertexCollection >( iConfig.getParameter< edm::InputTag >( "PrimaryVertices" ) ) )
  ,m_TagEcalEB_RecHits( consumes< EBRecHitCollection >( iConfig.getParameter<edm::InputTag>("EcalEBRecHits") ) )
  ,m_TagEcalEE_RecHits( consumes< EERecHitCollection >( iConfig.getParameter<edm::InputTag>("EcalEERecHits") ) )
  ,m_TagHcalHBHE_RecHits( consumes< HBHERecHitCollection >( iConfig.getParameter<edm::InputTag>("HBHERecHits") ) )
  ,m_TrackTag( consumes< reco::TrackCollection >( iConfig.getParameter< edm::InputTag >( "TrackTag" ) ) )
  ,m_TrajectoryTag(consumes<std::vector<Trajectory> >(iConfig.getParameter<edm::InputTag>("TrackTag") ) )
  ,m_assoMapTag(consumes<TrajTrackAssociationCollection>(iConfig.getParameter<edm::InputTag>("TrackTag") ) )
  ,m_Tag_Jets( consumes< reco::PFJetCollection >( iConfig.getParameter<edm::InputTag>("JetTag") ) )
  ,m_Tag_Photons( consumes< PhotonCollection >( iConfig.getParameter<edm::InputTag>("PhotonTag") ) )
  ,m_Tag_Electrons( consumes< ElectronCollection >( iConfig.getParameter<edm::InputTag>("ElectronTag") ) )
  ,m_Tag_MET( consumes< std::vector<reco::PFMET> >(iConfig.getParameter<edm::InputTag>("METTag") ) )
  ,m_Tag_bClusters( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("bcClusterTag") ) )
  ,m_Tag_cClusters( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("ccClusterTag") ) )
  ,m_Tag_combClusters( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("combClusterTag") ) )
  ,m_Tag_eeClean( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("eeCleanTag") ) )
  ,m_Tag_eeUnclean( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("eeUncleanTag") ) )
  ,m_Tag_eeComb( consumes< reco::BasicClusterCollection >(iConfig.getParameter<edm::InputTag>("eeCombTag") ) )
  ,m_isData(iConfig.getParameter<bool>("isData") )
  ,m_ecalObs(iConfig)
{
  m_isFirstEvent = true; 
  _Tracker         = new MplTracker(iConfig,consumesCollector());
  _PtCut           = iConfig.getUntrackedParameter<double>("TrackPtCut", 3.0);
  _PhiCut          = iConfig.getUntrackedParameter<double>("TrackPhiCut", 0.5);
  _Chi2Cut         = iConfig.getUntrackedParameter<double>("TrackChi2Cut", 5.0);
  _ClustHitOutput  = iConfig.getUntrackedParameter<bool>("ClustHitOutput", true);
  _EleJetPhoOutput = iConfig.getUntrackedParameter<bool>("EleJetPhoOutput", true);
  _TrackHitOutput  = iConfig.getUntrackedParameter<bool>("TrackHitOutput", false);
}


MonoNtupleDumper::~MonoNtupleDumper()
{ 
   // do anything here that needs to be done at desctruction time
   // (e.g. close files, deallocate resources etc.)
}

//
// member functions
//

void
MonoNtupleDumper::Init(const edm::EventSetup& iSetup) {

#ifdef DEBUG
  std::cout<<"Start: MplTracker::Init"<<std::endl;
#endif

  iSetup.get<GlobalTrackingGeometryRecord>().get(_TrackingGeom);

  //// Fill Normalization map                                                                                                                      
  //edm::ESHandle<TrackerGeometry> tkGeom;
  //iSetup.get<TrackerDigiGeometryRecord>().get( tkGeom );

  //const vector<const GeomDet*> Det = tkGeom->dets();
  //for(uint i=0; i<Det.size(); i++){
  //  DetId Detid = Det[i]->geographicalId();

  //  const StripGeomDetUnit* StripDetUnit = dynamic_cast<const StripGeomDetUnit*> (Det[i]);
  //   const PixelGeomDetUnit* PixelDetUnit = dynamic_cast<const PixelGeomDetUnit*> (Det[i]);

  //  if(StripDetUnit){
  //    _NormMap[Detid.rawId()] = _MeVperADCStrip / StripDetUnit->surface().bounds().thickness();
  //  }else if(PixelDetUnit){
  //_NormMap[Detid.rawId()] = _MeVperADCPixel / PixelDetUnit->surface().bounds().thickness();
  //  }
  //}

#ifdef DEBUG
  std::cout<<"End: MplTracker::Init"<<std::endl;
#endif
}

void
MonoNtupleDumper::RemovePoints(int n){
  for(int i=0; i<n; i++){
    _Points.pop_back();
    _Errors.pop_back();
    _Charges.pop_back();
    _SumHits.pop_back();
    _HighHits.pop_back();
  }
  //cout << "Just Removed " << n << ".  Sizes: " << _Points.size() << " " << _Errors.size() << " " << _Charges.size() << endl;
}

void 
MonoNtupleDumper::Clear(){
  _vGroup.clear();

  _vXYPar0.clear();
  _vXYPar1.clear();
  _vXYPar2.clear();
  _vXYErr0.clear();
  _vXYErr1.clear();
  _vXYErr2.clear();
  _vRZPar0.clear();
  _vRZPar1.clear();
  _vRZPar2.clear();
  _vRZErr0.clear();
  _vRZErr1.clear();
  _vRZErr2.clear();

  _vChi2XY.clear();
  _vChi2RZ.clear();
  _vNdof.clear();

  _vHits.clear();
  _vSatHits.clear();
  _vSubHits.clear();
  _vSatSubHits.clear();
  _vIso.clear();

  _vTHTrack.clear();
  _vTHX.clear();
  _vTHY.clear();
  _vTHZ.clear();
  _vTHErrX.clear();
  _vTHErrY.clear();
  _vTHErrZ.clear();

  _clustMatchEB.clear();
  _clustDistEB.clear();
  _clustMatchEBClean.clear();
  _clustDistEBClean.clear();
  _clustMatchEBUnclean.clear();
  _clustDistEBUnclean.clear();

  _clustMatchEE.clear();
  _clustDistEE.clear();
  _clustMatchEEClean.clear();
  _clustDistEEClean.clear();
  _clustMatchEEUnclean.clear();
  _clustDistEEUnclean.clear();
}

void 
MonoNtupleDumper::Save(vector<int> &Group){
  /*cout << "Outputting a track..." << endl << "Constituents: ";
  for(uint i=0; i<Group.size(); i++){
  cout << Group[i] << " ";
  }
  cout << endl;
  cout << "XYPars: " << _XYPar[0] << " +/- " << _XYErr[0] << " " << _XYPar[1] << " +/- " << _XYErr[1] << " " << _XYPar[2] << " +/- " << _XYErr[2] << endl;
  cout << "XYChi2: " << _Chi2XY << " / " << _NdofXY << endl;
  cout << "RZPars: " << _RZPar[0] << " +/- " << _RZErr[0] << " " << _RZPar[1] << " +/- " << _RZErr[1] << " " << _RZPar[2] << " +/- " << _RZErr[2] << endl;
  cout << "RZChi2: " << _Chi2RZ << " / " << _NdofRZ << endl;*/

  ostringstream csv;
  csv << Group[0];
  for(uint i=1; i<Group.size(); i++) csv << "," << Group[i];
  _vGroup.push_back(csv.str());

  _vXYPar0.push_back(_XYPar[0]);
  _vXYPar1.push_back(_XYPar[1]);
  _vXYPar2.push_back(_XYPar[2]);
  _vXYErr0.push_back(_XYErr[0]);
  _vXYErr1.push_back(_XYErr[1]);
  _vXYErr2.push_back(_XYErr[2]);
  _vRZPar0.push_back(_RZPar[0]);
  _vRZPar1.push_back(_RZPar[1]);
  _vRZPar2.push_back(_RZPar[2]);
  _vRZErr0.push_back(_RZErr[0]);
  _vRZErr1.push_back(_RZErr[1]);
  _vRZErr2.push_back(_RZErr[2]);

  _vChi2XY.push_back(_Chi2XY);
  _vChi2RZ.push_back(_Chi2RZ);
  _vNdof.push_back(_Ndof);

  _vIso.push_back(_Iso);

  int Hits = 0, SatHits=0, SubHits = 0, SatSubHits=0;

  for(uint i=0; i<_SumHits.size(); i++){
    Hits++;
    if(2*_HighHits[i]>=_SumHits[i]) SatHits++;

    SubHits += _SumHits[i];
    SatSubHits += _HighHits[i];
  }

  _vHits.push_back(Hits);
  _vSatHits.push_back(SatHits);
  _vSubHits.push_back(SubHits);
  _vSatSubHits.push_back(SatSubHits);

  //for(uint i=0; i<_Charges.size(); i++)
  //cout << "Charge: " << _Charges[i] << endl;
}

void 
MonoNtupleDumper::AverageIso(vector<int> &Group){
  edm::Ref<std::vector<reco::Track> > InitTrack(_hTracks, Group[0]);

  float InitEta = InitTrack->eta();
  float InitPhi = InitTrack->phi();
  float IsoPt = 0;

  for(uint i = 0; i!=_hTracks->size(); i++){
    if(count(Group.begin(), Group.end(), i) > 0) continue;

    edm::Ref<std::vector<reco::Track> > ThisTrack(_hTracks, i);

    //float dR2 = pow(ThisTrack->eta() - InitEta, 2) + pow(ThisTrack->phi() - InitPhi, 2);
    float dR2 = reco::deltaR(ThisTrack->eta(), ThisTrack->phi(), InitEta, InitPhi);

    if(dR2 > .16) continue; // dR cut of 0.4

    IsoPt += ThisTrack->pt();
  }

  _Iso = IsoPt;
}

int
MonoNtupleDumper::AddPoints(const reco::Track &Track){
  int NPoints = 0;

  // Find the right Trajectory
  const Trajectory *Traj=NULL;
  for(uint i=0; i < _hTrajectories->size(); i++){
    edm::Ref<std::vector<Trajectory> > TrajRef(_hTrajectories, i);
    edm::RefToBase<reco::Track> TrackRef ( (*_hTrajTrackAssociations.product())[TrajRef] );
    if(TrackRef->pt() == Track.pt() && TrackRef->eta() == Track.eta() && TrackRef->phi() == Track.phi()){
      Traj = TrajRef.get();
      break;
    }
  }
  if (Traj == NULL) cout << "Incoming!!!" << endl;

  for(trackingRecHit_iterator iHit=Track.recHitsBegin(); iHit!=Track.recHitsEnd(); iHit++){
    if(!((**iHit).isValid())) continue;
    
    LocalPoint LPos = (**iHit).localPosition();
    LocalError LErr = (**iHit).localPositionError();
    
    const GeomDet *Detector = _TrackingGeom->idToDet((**iHit).geographicalId());

    GlobalPoint GPos = Detector->toGlobal(LPos);
    
    _Points.push_back(GPos);
    
    double r2 = GPos.perp2();

    if(LErr.valid()){
      GlobalError GErr = ErrorFrameTransformer::transform( LErr, Detector->surface() );
      if(GErr.cxx() > 100 || GErr.cyy() > 100 || GErr.czz() > 100)
	_Errors.push_back(GlobalError(_DefaultError*r2, 0, _DefaultError*r2, 0, 0, _DefaultError*r2) );
      else
	_Errors.push_back(GErr + GlobalError(_ErrorFudge*r2, 0, _ErrorFudge*r2, 0, 0, _ErrorFudge*r2) ); //error bars are too small.
    }
    else{
      _Errors.push_back(GlobalError(_DefaultError*r2, 0, _DefaultError*r2, 0, 0, _DefaultError*r2) );
    }

    // add the dedx information: different accessor for every type of hit
    TrajectoryStateOnSurface State(Traj->geometricalInnermostState().globalParameters(), Detector->surface());
    LocalVector Direction = State.localDirection();
    double cosine   = Direction.z()/Direction.mag();
    float  Charge   = 0;
    int    HighHits = 0;
    int    SumHits  = 0;
   
    //Matched                                                                                                                                  
    const SiStripMatchedRecHit2D* matchedHit=dynamic_cast<const SiStripMatchedRecHit2D*>(&(**iHit));
    if(matchedHit){
      //                                                                                                                                       
    } 

    //Projected                                                                                                                                
    const ProjectedSiStripRecHit2D* projectedHit=dynamic_cast<const ProjectedSiStripRecHit2D*>(&(**iHit));
    if(projectedHit){
      const ProjectedSiStripRecHit2D::ClusterRef & cluster=projectedHit->cluster();
      const auto & Ampls = cluster->amplitudes();
      SumHits += Ampls.size();
      for(uint i=0; i<Ampls.size(); i++){
	Charge += Ampls[i];
	if(Ampls[i] >= 254) HighHits++;
      }
    }//end of projectedHit
    
    //2D                                                                                                                                       
    const SiStripRecHit2D* singleHit=dynamic_cast<const SiStripRecHit2D*>(&(**iHit));
    if(singleHit){
      const SiStripRecHit2D::ClusterRef & cluster=singleHit->cluster();
      const auto & Ampls = cluster->amplitudes();
      SumHits += Ampls.size();
      for(uint i=0; i<Ampls.size(); i++){
	Charge += Ampls[i];
	if(Ampls[i] >= 254) HighHits++;
      }
    }//end of singleHit                                                                                                                        

    //1D                                                                                                                                       
    const SiStripRecHit1D* single1DHit=dynamic_cast<const SiStripRecHit1D*>(&(**iHit));
    if(single1DHit){
      const SiStripRecHit1D::ClusterRef & cluster=single1DHit->cluster();
      const auto & Ampls = cluster->amplitudes();
      SumHits += Ampls.size();
      for(uint i=0; i<Ampls.size(); i++){
	Charge += Ampls[i];
	if(Ampls[i] >= 254) HighHits++;
      }
    }//end of single1DHit                                                                                                                      

    //Added dedx cut
    if(HighHits>=18 && HighHits>=SumHits-5) continue;

    float NormCharge = _NormMap[(**iHit).geographicalId().rawId()] * Charge * abs(cosine);

    if(NormCharge > 0 && NormCharge < _DeDxCut){
      _Points.pop_back();
      _Errors.pop_back();
      continue;
    }
    
    _Charges.push_back(NormCharge);
    _SumHits.push_back(SumHits);
    _HighHits.push_back(HighHits);
    
    NPoints++;
  }
  return NPoints;
}

void
MonoNtupleDumper::AddMoreTracks(vector<int> &Group){
  edm::Ref<std::vector<reco::Track> > InitTrack(_hTracks, Group[0]);
  //edm::RefToBase<reco::Track> InitTrack ( (*_hTrajTrackAssociations.product())[InitTrajRef] );

  //cout << "Checking: " << Group[0] << " " << InitTrack->phi() << endl;

  for(uint i = Group.back()+1; i!=_hTracks->size(); i++){
    if(_Used.count(i) > 0) continue;

    edm::Ref<std::vector<reco::Track> > ThisTrack(_hTracks, i);
    //edm::RefToBase<reco::Track> ThisTrack ( (*_hTrajTrackAssociations.product())[ThisTrajRef] );

    if(ThisTrack->pt() < _PtCut){
      //cout << " Pt too low: " << ThisTrack->pt() << endl;
      continue;
    }

    /*    float DeDx = (*_hDeDx.product())[ThisTrack].dEdx();
    if( DeDx > 0 && DeDx < _DeDxCut){
    //cout << "Track " << i << " DeDx too low." << endl;
      continue;
      }*/
    
    //cout << " " << i << " " << ThisTrack->phi() << endl;

    if(fabs(ThisTrack->phi() - InitTrack->phi()) > _PhiCut) continue;

    //cout << " Passed Phi Cut" << endl;

    int NPoints = MonoNtupleDumper::AddPoints(*ThisTrack);
    if(NPoints == 0) continue;

    /*
    FitXY(Group);
    //cout << " Chi2XY: " << _Chi2XY / _NdofXY << endl;
    if(_Ndof > 0 && _Chi2XY / _Ndof > _Chi2Cut){
      RemovePoints(NPoints);
      continue;
    }
    
    FitRZ();
    //cout << " Chi2RZ: " << _Chi2RZ / _NdofRZ << endl;
    if(_Ndof > 0 && _Chi2RZ / _Ndof > _Chi2Cut){
      RemovePoints(NPoints);
      continue;
    }
    */

    MonoNtupleDumper::AverageIso(Group);
    
    MonoNtupleDumper::Save(Group);

    //cout << " Good!" << endl;
    Group.push_back(i);
  }
}

// ------------ method called for each event  ------------
void
MonoNtupleDumper::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
{
  clear();
  m_run = iEvent.id().run();
  m_lumi = iEvent.id().luminosityBlock();
  m_event = iEvent.id().event();

#ifdef DEBUG
  std::cout<<"Start ntuple production"<<std::endl;
  std::cout<<"PASS: EventSetup"<<std::endl;
#endif
  
  ////////////////////////////////////
  // get a handle on the trigger results
  Handle<edm::TriggerResults> HLTR;
  iEvent.getByToken(m_hltResults,HLTR);

  // get a list of trigger names
  //std::vector<std::string> hltNames = m_hltConfig.triggerNames();
  edm::TriggerNames hltNames(iEvent.triggerNames(*HLTR));
  const std::vector<std::string> & hltNameVec = hltNames.triggerNames();

  // fill trigger names and set the size of the trigger result vector
  if ( m_isFirstEvent ) {
    m_isFirstEvent=false;
    m_NTrigs = HLTR->size();
    m_trigResults.resize(m_NTrigs);
    m_trigNames.resize(m_NTrigs);
    
    for ( unsigned i=0; i != m_NTrigs; i++ )
      m_trigNames[i] = hltNameVec[i];
  } 
  // check order of trigger names does not change
  // uncomment to run check.  Otherwise, it will take up time.
  /*else {
    for ( unsigned i=9; i != m_NTrigs; i++ ) {
    assert(m_trigNames[i].compare(hltNameVec[i])); 
    }
    }
  */
  
  // cycle over trigger names
  const unsigned nNames = HLTR->size();
  for ( unsigned i=0; i != nNames; i++ ) {
    m_trigResults[i] = HLTR->accept(i);
    
    // a very verbose debug statement!!
    //cout << m_trigNames[i] << " " << HLTR->accept(i) << endl;
  }
  
  /////////////////////////////////////
  // get NPV for this event
  m_NPV = 0;
  edm::Handle<reco::VertexCollection> handlePV;
  iEvent.getByToken(m_PVTag,handlePV);
  reco::VertexCollection::const_iterator pv = handlePV->begin();
  for ( ; pv != handlePV->end(); pv++ ) {
    if ( !pv->isFake() && pv->ndof() > 4.0 ) {
      ++m_NPV;
    }
  }

#ifdef DEBUG
  std::cout<<"Pass: NPV"<<std::endl;
#endif

  // execute observable calculations
  // double monoObs = m_ecalObs.calculate(iSetup,iEvent,&m_betas,&m_betaTs);
  //const Mono::EBmap & ebMap = m_ecalObs.ecalMap();

  //#ifdef DEBUG
  //std::cout<<"Pass: EBmap"<<std::endl;
  //#endif

  // limits in eta and phi of ebmap
  //const unsigned nEta = ebMap.nEta();
  //const unsigned nPhi = ebMap.nPhi();

  // initialize the MC monopole tagger to tag MC monopoels fo RECO objects
  //Mono::GenMonoClusterTagger tagger(0.3);
  //tagger.initialize(iEvent,iSetup,iC);

  //#ifdef DEBUG
  //std::cout<<"Pass: Mono::GenMonoClusterTagger"<<std::endl;
  //#endif

  /////////////////////////////////////
  // cluster analysis
  // retrieve the clusterBuilder from the ecal obs.
  /*const Mono::ClusterBuilder clusterBuilder = m_ecalObs.clusterBuilder();
  m_nClusters = clusterBuilder.nClusters();

  // tag clusters to gen level monopole extrapolation
  Mono::GenMonoClusterTagger tagger(0.3);
  if ( !m_isData ) {
    tagger.initialize(iEvent,iSetup);
    if ( m_nClusters ) tagger.tag(m_nClusters,clusterBuilder.clusters(),ebMap);
  }


  // cycle of all clusters found
  for ( unsigned i=0; i != m_nClusters; i++ ) {
    const Mono::MonoEcalCluster & cluster = clusterBuilder.clusters()[i];

    // get basic cluster info
    const unsigned width = cluster.clusterWidth();
    const unsigned length = cluster.clusterLength();
    const unsigned cEta = cluster.ieta();
    const unsigned cPhi = cluster.iphi();

    // get MC monopole tag info
    if ( !m_isData ) {
      m_clust_matchDR.push_back(tagger.matchDR()[i]);
      m_clust_tagged.push_back(tagger.tagResult()[i]);
      m_clust_matchPID.push_back(tagger.matchPID()[i]);
      m_clust_matchTime.push_back(tagger.matchTime()[i]);
      m_clust_matchPt.push_back(tagger.matchPt()[i]);
    }

    m_clust_E.push_back( cluster.clusterEnergy() );
    m_clust_eta.push_back( ebMap.eta(cEta) );
    m_clust_phi.push_back( ebMap.phi(cPhi) );
    m_clust_L.push_back( length );
    m_clust_W.push_back( width );

    // prepare 2D histograms to facilitate some basic analysis on the clusters
    // like skewness
    const unsigned wings = width/2U;
    char histName[50];
    sprintf(histName,"clustHist_%llu_%d",iEvent.id().event(),i);
    TH2D hist(histName,histName,length,-(float)length/2.,(float)length/2.,width,-(int)wings,wings);
    sprintf(histName,"clustTHist_%llu_%d",iEvent.id().event(),i);
    TH2D Thist(histName,histName,length,0,length,width,-(int)wings,wings);

    double histMax=0.;
    double hsTime=-1.;
    int phiBin=UINT_MAX;
    bool kWeird=false;
    bool kDiWeird=false;

    // fill in cluster energy and time maps
    const bool exceedsWS = length*width > WS;
    const bool exceedsSS = length*width+i*WS > SS;
    const bool excessive = exceedsWS || exceedsSS;
    for ( unsigned j=0; j != width; j++ ) {
      int ji = (int)j-(int)width/2;
      for ( unsigned k=0; k != length; k++ ) {
        const double energy = cluster.energy(k,ji,ebMap);
	if ( energy > histMax ) {
	  histMax = energy;
	  hsTime = cluster.time(k,ji,ebMap);
	  phiBin = ji;
       	  kWeird = cluster.getRecHit(k,ji,ebMap)->checkFlag( EcalRecHit::kWeird );
       	  kDiWeird = cluster.getRecHit(k,ji,ebMap)->checkFlag( EcalRecHit::kDiWeird );
	}
	hist.SetBinContent(k+1,j+1,energy);
	Thist.SetBinContent(k+1,j+1,cluster.time(k,ji,ebMap));
	if ( !excessive ) m_clust_Ecells[i*WS+j*length+k] = cluster.energy(k,ji,ebMap);
	if ( !excessive ) m_clust_Tcells[i*WS+j*length+k] = cluster.time(k,ji,ebMap);
      }
    }

    m_clust_sigEta.push_back( hist.GetRMS(1) );
    m_clust_sigPhi.push_back( hist.GetRMS(2) );
    m_clust_skewEta.push_back( hist.GetSkewness(1) );
    m_clust_skewPhi.push_back( hist.GetSkewness(2) );

    const double clustE = cluster.clusterEnergy();
    m_clust_seedFrac.push_back( cluster.clusterSeed().energy()/clustE );
    const unsigned center = length/2U;
    m_clust_firstFrac.push_back( cluster.energy(center,0,ebMap)/clustE );
    m_clust_secondFrac.push_back( (cluster.energy(center+1U,0,ebMap)+cluster.energy(center-1U,0,ebMap))/clustE );
    m_clust_thirdFrac.push_back( (cluster.energy(center+2U,0,ebMap)+cluster.energy(center-2U,0,ebMap))/clustE );

    m_clust_hsE.push_back(histMax/clustE);
    m_clust_hsTime.push_back(hsTime);
    m_clust_hsInSeed.push_back(phiBin);
    m_clust_hsWeird.push_back( kWeird );
    m_clust_hsDiWeird.push_back( kDiWeird );

    // perform Gaussian fit to cluster
    // normalise to total energy of cluster
    hist.Scale( 1./cluster.clusterEnergy() );

    // fill in aggregate cluster information maps
    Mono::ClustCategorizer cluCat(length,width);
    std::map<Mono::ClustCategorizer,TH2D*>::iterator enIter = m_clustEMap.find(cluCat);
    std::map<Mono::ClustCategorizer,TH2D*>::iterator tmIter = m_clustTMap.find(cluCat);
    bool foundEn = enIter == m_clustEMap.end();
    bool foundTm = tmIter == m_clustTMap.end();
    assert( foundEn == foundTm ); // assert maps are somewhat synchronous

    // if category not found create the histogram
    if ( foundEn ) {
      char name[50];
      sprintf(name,"avgEnClust_%d_%d",cluCat.length,cluCat.width);
      m_clustEMap[cluCat] = new TH2D(name,name,cluCat.length,0,cluCat.length,cluCat.width,-(int)cluCat.width/2,(int)cluCat.width/2);
      sprintf(name,"avgTmClust_%d_%d",cluCat.length,cluCat.width);
      m_clustTMap[cluCat] = new TH2D(name,name,cluCat.length,0,cluCat.length,cluCat.width,-(int)cluCat.width/2,(int)cluCat.width/2);
    }

    m_clustCatCount[cluCat]++;
    TH2D * avgEnMap = m_clustEMap[cluCat];
    TH2D * avgTmMap = m_clustTMap[cluCat];

    assert( avgEnMap );
    assert( avgTmMap );

    for ( int binx = 1; binx <= hist.GetNbinsX(); binx++ ) {
      for ( int biny = 1; biny <= hist.GetNbinsY(); biny++ ) {
	if ( !m_isData && tagger.tagResult()[i] && tagger.matchPID()[i] < 0 ) { 
	  avgEnMap->SetBinContent(binx,biny,avgEnMap->GetBinContent(binx,biny)+hist.GetBinContent(binx,biny));
      	  avgTmMap->SetBinContent(binx,biny,avgTmMap->GetBinContent(binx,biny)+Thist.GetBinContent(binx,biny));
	} 
      }
    }
    

  } */

  // get RecHit collection
  Handle<EBRecHitCollection > ecalRecHits;
  iEvent.getByToken(m_TagEcalEB_RecHits,ecalRecHits);
  assert( ecalRecHits->size() > 0 );

  // get EE RecHit collection
  Handle<EERecHitCollection > eeRecHits;
  iEvent.getByToken(m_TagEcalEE_RecHits,eeRecHits);
  assert( eeRecHits->size() > 0 );

  // get HB RecHit Collection
  Handle<HBHERecHitCollection> hbRecHits;
  iEvent.getByToken(m_TagHcalHBHE_RecHits,hbRecHits);
  assert( hbRecHits->size() > 0 );

  // get calo geometry and topology
  ESHandle<CaloGeometry> calo;
  iSetup.get<CaloGeometryRecord>().get(calo);
  const CaloGeometry *m_caloGeo = (const CaloGeometry*)calo.product();
  const CaloSubdetectorGeometry *geom = m_caloGeo->getSubdetectorGeometry(DetId::Ecal,EcalBarrel);

  ESHandle<CaloTopology> topo;
  iSetup.get<CaloTopologyRecord>().get(topo);
  const CaloTopology * topology = (const CaloTopology*)topo.product();

  // get HE geometry and topology
  // get HB geometry and topology
  //SimpleCaloRecHitMetaCollection< HBHERecHitCollection > mhbrh(hbRecHits.product());
  EgammaHcalIsolation egIso(0.4,0.1,10.,10.,10.,10.,calo,*hbRecHits);

  // fill RecHit branches
  EBRecHitCollection::const_iterator itHit = ecalRecHits->begin();
  for ( ; itHit != ecalRecHits->end(); itHit++ ) {

    EBDetId detId( (*itHit).id() );
    const CaloCellGeometry *cell = geom->getGeometry( detId );

    m_ehit_eta.push_back( cell->getPosition().eta() );
    m_ehit_phi.push_back( cell->getPosition().phi() );
    m_ehit_energy.push_back( (*itHit).energy() );
    m_ehit_time.push_back( (*itHit).time() );
    // the outOfTimeEnergy method has been removed from the EcalRecHit class
    // in CMSSW_7.  I leave this commment here is a note/reminder this is something
    // I don't immediately know how to fix, but this analyzer is not used much
    // so it doesn't need to be fixed at the moment.
    //m_ehit_otEnergy.push_back( (*itHit).outOfTimeEnergy() );

    m_ehit_kWeird.push_back( (*itHit).checkFlag(EcalRecHit::kWeird) );
    m_ehit_kDiWeird.push_back( (*itHit).checkFlag(EcalRecHit::kDiWeird) );
    m_ehit_flag.push_back( (*itHit).recoFlag() );

  }

  // get BasicCluster Collection
  Handle<BasicClusterCollection> bClusters;
  iEvent.getByToken(m_Tag_bClusters,bClusters);
  const unsigned nbClusters = bClusters->size();

  EcalClusterTools ecalTool;
  std::vector<int> exclFlags;
  std::vector<int> sevExcl;

  std::vector<const reco::CaloCluster *> ebUncleanClusters;

  //tagger.clearTags();
  //if ( !m_isData && nbClusters ) tagger.tag(nbClusters,&(*bClusters)[0]);

  unsigned nClusterCount=0;
  for ( unsigned i=0; i != nbClusters; i++ ) {
    if ( (*bClusters)[i].energy() < 50. ) continue;

    ebUncleanClusters.push_back( &(*bClusters)[i] );

    nClusterCount++;
    m_egClust_E.push_back( (*bClusters)[i].energy() );
    m_egClust_size.push_back( (*bClusters)[i].size() );
    m_egClust_eta.push_back( (*bClusters)[i].eta() );
    m_egClust_phi.push_back( (*bClusters)[i].phi() );

    const float e55 = ecalTool.e5x5((*bClusters)[i],ecalRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*bClusters)[i],ecalRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*bClusters)[i],ecalRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*bClusters)[i],ecalRecHits.product());
    m_egClust_frac51.push_back( e51/e55 );
    m_egClust_frac15.push_back( e15/e55 );
    m_egClust_e55.push_back(e55);
    m_egClust_eMax.push_back(eMax/e55);
    m_egClust_hcalIso.push_back( egIso.getHcalESum((*bClusters)[i].position()) );

    if ( !m_isData ) {
      //m_egClust_matchDR.push_back(tagger.matchDR()[i]);
      //m_egClust_tagged.push_back(tagger.tagResult()[i]);
      //m_egClust_matchPID.push_back(tagger.matchPID()[i]);
    }
  }
  m_nClusterEgamma = nClusterCount;

  // get BasicCluster Collection (cleaned)
  Handle<BasicClusterCollection> cClusters;
  iEvent.getByToken(m_Tag_cClusters,cClusters);
  const unsigned ncClusters = cClusters->size();

  std::vector<const reco::CaloCluster *> ebCleanClusters;

  //tagger.clearTags();
  //if ( !m_isData && ncClusters ) tagger.tag(ncClusters,&(*cClusters)[0]);

  nClusterCount=0;
  for ( unsigned i=0; i != ncClusters; i++ ) {
    if ( (*cClusters)[i].energy() < 50. ) continue;

    ebCleanClusters.push_back( &(*cClusters)[i] );

    nClusterCount++;
    m_egClean_E.push_back( (*cClusters)[i].energy() );
    m_egClean_size.push_back( (*cClusters)[i].size() );
    m_egClean_eta.push_back( (*cClusters)[i].eta() );
    m_egClean_phi.push_back( (*cClusters)[i].phi() );

    const float e55 = ecalTool.e5x5((*cClusters)[i],ecalRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*cClusters)[i],ecalRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*cClusters)[i],ecalRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*cClusters)[i],ecalRecHits.product());
    m_egClean_frac51.push_back( e51/e55 );
    m_egClean_frac15.push_back( e15/e55 );
    m_egClean_e55.push_back(e55);
    m_egClean_eMax.push_back(eMax/e55);
    m_egClean_hcalIso.push_back( egIso.getHcalESum((*cClusters)[i].position()) );

    if ( !m_isData ) {
      //m_egClean_matchDR.push_back(tagger.matchDR()[i]);
      //m_egClean_tagged.push_back(tagger.tagResult()[i]);
      //m_egClean_matchPID.push_back(tagger.matchPID()[i]);
    }
  }
  m_nCleanEgamma = nClusterCount;

  // get BasicCluster Collection (combined)
  Handle<reco::BasicClusterCollection> combClusters;
  iEvent.getByToken(m_Tag_combClusters,combClusters);
  const unsigned ncombClusters = combClusters->size();

  std::vector<const reco::CaloCluster *> ebClusters;

  //tagger.clearTags();
  //if ( !m_isData && ncombClusters ) tagger.tag(ncombClusters,&(*combClusters)[0]);

  nClusterCount=0;
  for ( unsigned i=0; i != ncombClusters; i++ ) {
    //if ( (*combClusters)[i].energy() < 50. ) continue;

    ebClusters.push_back( &(*combClusters)[i] );

    nClusterCount++;
    m_egComb_E.push_back( (*combClusters)[i].energy() );
    m_egComb_size.push_back( (*combClusters)[i].size() );
    m_egComb_eta.push_back( (*combClusters)[i].eta() );
    m_egComb_phi.push_back( (*combClusters)[i].phi() );

    const float e55 = ecalTool.e5x5((*combClusters)[i],ecalRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*combClusters)[i],ecalRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*combClusters)[i],ecalRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*combClusters)[i],ecalRecHits.product());
    m_egComb_frac51.push_back( e51/e55 );
    m_egComb_frac15.push_back( e15/e55 );
    m_egComb_e55.push_back(e55);
    m_egComb_eMax.push_back(eMax/e55);
    m_egComb_e25Right.push_back(ecalTool.e2x5Right((*combClusters)[i],ecalRecHits.product(),topology));
    m_egComb_e25Left.push_back(ecalTool.e2x5Left((*combClusters)[i],ecalRecHits.product(),topology));
    m_egComb_hcalIso.push_back( egIso.getHcalESum((*combClusters)[i].position()) );

    if ( !m_isData ) {
      //m_egComb_matchDR.push_back(tagger.matchDR()[i]);
      //m_egComb_tagged.push_back(tagger.tagResult()[i]);
      //m_egComb_matchPID.push_back(tagger.matchPID()[i]);
    }
  }
  m_nCombEgamma = nClusterCount;

  //
  // ------------- EE clusters ----------------------
  // get basic clusters
  Handle<BasicClusterCollection> eeClean;
  iEvent.getByToken(m_Tag_eeClean,eeClean);
  const unsigned nEECleanClusters = eeClean->size();

  std::vector<const reco::CaloCluster *> eeCleanClusters;

  //tagger.clearTags();
  //Mono::GenMonoClusterTagger eetagger(0.3,false);
  //if ( !m_isData && nEECleanClusters ) eetagger.tag(nEECleanClusters,&(*eeClean)[0]);

  nClusterCount=0;
  for ( unsigned i=0; i != nEECleanClusters; i++ ) {
    if ( (*eeClean)[i].energy() < 50. ) continue;

    eeCleanClusters.push_back( &(*eeClean)[i] );

    nClusterCount++;
    m_eeClean_E.push_back( (*eeClean)[i].energy() );
    m_eeClean_size.push_back( (*eeClean)[i].size() );
    m_eeClean_eta.push_back( (*eeClean)[i].eta() );
    m_eeClean_phi.push_back( (*eeClean)[i].phi() );

    const float e55 = ecalTool.e5x5((*eeClean)[i],eeRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*eeClean)[i],eeRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*eeClean)[i],eeRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*eeClean)[i],eeRecHits.product());
    m_eeClean_frac51.push_back( e51/e55 );
    m_eeClean_frac15.push_back( e15/e55 );
    m_eeClean_e55.push_back(e55);
    m_eeClean_eMax.push_back(eMax/e55);
    m_eeClean_hcalIso.push_back( egIso.getHcalESum((*eeClean)[i].position()) );

    if ( !m_isData ) {
      //m_eeClean_matchDR.push_back(eetagger.matchDR()[i]);
      //m_eeClean_tagged.push_back(eetagger.tagResult()[i]);
      //m_eeClean_matchPID.push_back(eetagger.matchPID()[i]);
    }
  }
  m_nCleanEE = nClusterCount;

  // unclean only clusters (EE)
  Handle<BasicClusterCollection> eeUnclean;
  iEvent.getByToken(m_Tag_eeUnclean,eeUnclean);
  const unsigned nEEUncleanClusters = eeUnclean->size();

  std::vector<const reco::CaloCluster *> eeUncleanClusters;

  //eetagger.clearTags();
  //if ( !m_isData && nEEUncleanClusters ) eetagger.tag(nEEUncleanClusters,&(*eeUnclean)[0]);

  nClusterCount=0;
  for ( unsigned i=0; i != nEEUncleanClusters; i++ ) {
    if ( (*eeUnclean)[i].energy() < 50. ) continue;

    eeUncleanClusters.push_back( &(*eeUnclean)[i] );

    nClusterCount++;
    m_eeUnclean_E.push_back( (*eeUnclean)[i].energy() );
    m_eeUnclean_size.push_back( (*eeUnclean)[i].size() );
    m_eeUnclean_eta.push_back( (*eeUnclean)[i].eta() );
    m_eeUnclean_phi.push_back( (*eeUnclean)[i].phi() );

    const float e55 = ecalTool.e5x5((*eeUnclean)[i],eeRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*eeUnclean)[i],eeRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*eeUnclean)[i],eeRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*eeUnclean)[i],eeRecHits.product());
    m_eeUnclean_frac51.push_back( e51/e55 );
    m_eeUnclean_frac15.push_back( e15/e55 );
    m_eeUnclean_e55.push_back(e55);
    m_eeUnclean_eMax.push_back(eMax/e55);
    m_eeUnclean_hcalIso.push_back( egIso.getHcalESum((*eeUnclean)[i].position()) );

    if ( !m_isData ) {
      //m_eeUnclean_matchDR.push_back(eetagger.matchDR()[i]);
      //m_eeUnclean_tagged.push_back(eetagger.tagResult()[i]);
      //m_eeUnclean_matchPID.push_back(eetagger.matchPID()[i]);
    }
  }
  m_nUncleanEE = nClusterCount;

  // combined EE clusters
  Handle<BasicClusterCollection> eeComb;
  iEvent.getByToken(m_Tag_eeComb,eeComb);
  const unsigned nEECombClusters = eeComb->size();

  std::vector<const reco::CaloCluster *> eeCombClusters;

  //eetagger.clearTags();
  //if ( !m_isData && nEECombClusters ) eetagger.tag(nEECombClusters,&(*eeComb)[0]);

  nClusterCount=0;
  for ( unsigned i=0; i != nEECombClusters; i++ ) {
    //if ( (*eeComb)[i].energy() < 50. ) continue;

    eeCombClusters.push_back( &(*eeComb)[i] );

    nClusterCount++;
    m_eeComb_E.push_back( (*eeComb)[i].energy() );
    m_eeComb_size.push_back( (*eeComb)[i].size() );
    m_eeComb_eta.push_back( (*eeComb)[i].eta() );
    m_eeComb_phi.push_back( (*eeComb)[i].phi() );

    const float e55 = ecalTool.e5x5((*eeComb)[i],eeRecHits.product(),topology);
    const float e51 = ecalTool.e5x1((*eeComb)[i],eeRecHits.product(),topology);
    const float e15 = ecalTool.e1x5((*eeComb)[i],eeRecHits.product(),topology);
    const float eMax = ecalTool.eMax((*eeComb)[i],eeRecHits.product());
    m_eeComb_frac51.push_back( e51/e55 );
    m_eeComb_frac15.push_back( e15/e55 );
    m_eeComb_e55.push_back(e55);
    m_eeComb_eMax.push_back(eMax/e55);
    m_eeComb_e25Right.push_back(ecalTool.e2x5Right((*eeComb)[i],eeRecHits.product(),topology));
    m_eeComb_e25Left.push_back(ecalTool.e2x5Left((*eeComb)[i],eeRecHits.product(),topology));
    m_eeComb_hcalIso.push_back( egIso.getHcalESum((*eeComb)[i].position()) );

    if ( !m_isData ) {
      //m_eeComb_matchDR.push_back(eetagger.matchDR()[i]);
      //m_eeComb_tagged.push_back(eetagger.tagResult()[i]);
      //m_eeComb_matchPID.push_back(eetagger.matchPID()[i]);
    }
  }
  m_nCombEE = nClusterCount;
  
#ifdef DEBUG
  std::cout<<"Pass: Mono::GenMonoClusterTagger"<<std::endl;
#endif 

  ////////////////////////////////
  // Tracking analysis
  if(_NormMap.size() == 0) MonoNtupleDumper::Init(iSetup);  
  //edm::Handle<reco::TrackCollection> _hTracks;
  iEvent.getByToken(m_TrackTag,_hTracks);
  iEvent.getByToken(m_TrajectoryTag,_hTrajectories);
  iEvent.getByToken(m_assoMapTag,_hTrajTrackAssociations);
  //Loop over tracks
  for(uint i = 0; i!=_hTracks->size();i++){
    edm::Ref<std::vector<reco::Track> > TrackRef(_hTracks,i);
    if(TrackRef->pt()<_PtCut){
      std::cout<<"   + Track "<<i<<" Pt "<<TrackRef->pt()<<" too low."<<std::endl;
      continue;
    }
    // Output Track hits:
    for(trackingRecHit_iterator iHit=TrackRef->recHitsBegin(); iHit!=TrackRef->recHitsEnd(); iHit++){

      _vTHTrack.push_back(i);

      //TrackingRecHitRef Ref = *iHit;
      //const TrackingRecHit *Hit = &(*Ref);
      //if(!Hit->isValid()) continue;
      if(!((**iHit).isValid())) continue;

      LocalPoint LPos = (**iHit).localPosition();
      LocalError LErr = (**iHit).localPositionError();

      const GeomDet *Detector = _TrackingGeom->idToDet((**iHit).geographicalId());

      GlobalPoint GPos = Detector->toGlobal(LPos);
      _vTHX.push_back(GPos.x());
      _vTHY.push_back(GPos.y());
      _vTHZ.push_back(GPos.z());

      if(LErr.valid()){
        GlobalError GErr = ErrorFrameTransformer::transform( LErr, Detector->surface() );
        //GlobalError GErr = GlobalError(LErr.xx(), LErr.xy(), LErr.yy(), 0, 0, 0);
        //GErr = GlobalError(Detector->GErr.matrix());
        _vTHErrX.push_back(sqrt(GErr.cxx()));
        _vTHErrY.push_back(sqrt(GErr.cyy()));
        _vTHErrZ.push_back(sqrt(GErr.czz()));
      }
      else{
        _vTHErrX.push_back(0);
        _vTHErrY.push_back(0);
        _vTHErrZ.push_back(0);
      }
      
      int Strips=0, SatStrips=0;
      
      //Matched
      const SiStripMatchedRecHit2D* matchedHit=dynamic_cast<const SiStripMatchedRecHit2D*>(&(**iHit));
      if(matchedHit){
	//
      }
#ifdef DEBUG
      std::cout<<"   +After Matched: Strips = "<<Strips<<", SatStrips = "<<SatStrips<<std::endl;
#endif
      
      //Projected
      const ProjectedSiStripRecHit2D* projectedHit=dynamic_cast<const ProjectedSiStripRecHit2D*>(&(**iHit));
      if(projectedHit){
#ifdef DEBUG
	std::cout<<" ProjectedRecHit2D "<<std::ios::hex<<projectedHit<<std::endl;
#endif
	const ProjectedSiStripRecHit2D::ClusterRef & cluster=projectedHit->cluster();
	const auto & Ampls = cluster->amplitudes();
	Strips += Ampls.size();
	for(uint i=0; i<Ampls.size(); i++){
          if(Ampls[i] >= 254) SatStrips++;
	}
      }//end of projectedHit
#ifdef DEBUG
      std::cout<<"   +After Projected: Strips = "<<Strips<<", SatStrips = "<<SatStrips<<std::endl;
#endif
      
      //2D
      const SiStripRecHit2D* singleHit=dynamic_cast<const SiStripRecHit2D*>(&(**iHit));
      if(singleHit){
#ifdef DEBUG
	std::cout<<" RecHit2D "<<std::ios::hex<<singleHit<<std::endl;
#endif
	const SiStripRecHit2D::ClusterRef & cluster=singleHit->cluster();
        const auto & Ampls = cluster->amplitudes();
        Strips += Ampls.size();
        for(uint i=0; i<Ampls.size(); i++){
	  if(Ampls[i] >= 254) SatStrips++;
        }
      }//end of singleHit
#ifdef DEBUG
      std::cout<<"   +After 2D: Strips = "<<Strips<<", SatStrips = "<<SatStrips<<std::endl;
#endif      

      //1D
      const SiStripRecHit1D* single1DHit=dynamic_cast<const SiStripRecHit1D*>(&(**iHit));
      if(single1DHit){
#ifdef DEBUG
        std::cout<<" RecHit1D "<<std::ios::hex<<single1DHit<<std::endl;
#endif                                                                                                                                 
        const SiStripRecHit1D::ClusterRef & cluster=single1DHit->cluster();
	const auto & Ampls = cluster->amplitudes();
	Strips += Ampls.size();
        for(uint i=0; i<Ampls.size(); i++){
          if(Ampls[i] >= 254) SatStrips++;
        }
      }//end of single1DHit
#ifdef DEBUG
      std::cout<<"   +After 1D: Strips = "<<Strips<<", SatStrips = "<<SatStrips<<std::endl;
#endif

#ifdef DEBUG
      std::cout<<"Pass: SiStrip"<<std::endl;
#endif

      //Pixel

      //Added dedx cut:
      if(SatStrips>=18 && SatStrips>=Strips-5) continue;

#ifdef DEBUG
      std::cout<<"Pass: SatStrip cut"<<std::endl;
#endif

      _vTHStrips.push_back(Strips);
      _vTHSatStrips.push_back(SatStrips);
    }//end of "Output Track hits"

    //DeDx
    
    if(_Used.count(i)>0) continue;

#ifdef DEBUG
    std::cout<<"Pass: _Used.count"<<std::endl;
#endif

    vector<int> Group;
    Group.push_back(i);

    _Points.clear();
    _Errors.clear();
    _Charges.clear();
    _SumHits.clear();
    _HighHits.clear();

#ifdef DEBUG
    std::cout<<"Pass: Group and clear"<<std::endl;
#endif

    AddPoints(*TrackRef);
    AddMoreTracks(Group);
#ifdef DEBUG
    std::cout<<"Pass: AddMoreTracks"<<std::endl;
#endif

    //FitXY(Group);
#ifdef DEBUG
    std::cout<<"Pass: FitXY"<<std::endl;
#endif

    //FitRZ();
#ifdef DEBUG
    std::cout<<"Pass: FitRZ"<<std::endl;
#endif

    //FitDeDx();

  }//end of "Loop over tracks"

  _Tracker->analyze(iEvent,iSetup);
  //const Mono::MonoEcalCluster * clusters = clusterBuilder.clusters(); 
  ////_Tracker->doMatch(m_nClusters,clusters,ebMap);
  //_Tracker->doMatch(m_nCombEgamma,&ebClusters[0],fEBCombined);
  //_Tracker->doMatch(m_nCleanEgamma,&ebCleanClusters[0],fEBClean);
  //_Tracker->doMatch(m_nClusterEgamma,&ebUncleanClusters[0],fEBUnclean);
  //_Tracker->doMatch(m_nCombEE,&eeCombClusters[0],fEECombined);
  //_Tracker->doMatch(m_nCleanEE,&eeCleanClusters[0],fEEClean);
  //_Tracker->doMatch(m_nUncleanEE,&eeUncleanClusters[0],fEEUnclean);
  
#ifdef DEBUG
  std::cout<<"Pass: Tracker"<<std::endl;
#endif

  ////////////////////////////////    
  // get jet collection
  Handle<reco::PFJetCollection> jets;
  iEvent.getByToken(m_Tag_Jets,jets);
  const unsigned nJets = jets->size();

  // fill jet branches
  //tagger.clearTags();
  //if ( !m_isData && nJets ) tagger.tag(nJets,&(*jets)[0]);
  for ( unsigned i=0; i != nJets; i++ ) {

    const reco::PFJet & jet = (*jets)[i];

    m_jet_E.push_back( jet.energy() );
    m_jet_p.push_back( jet.p() );
    m_jet_pt.push_back( jet.pt() );
    m_jet_px.push_back( jet.px() );
    m_jet_py.push_back( jet.py() );
    m_jet_pz.push_back( jet.pz() );
    m_jet_eta.push_back( jet.eta() );
    m_jet_phi.push_back( jet.phi() );

    if ( !m_isData ) {
      //m_jet_matchDR.push_back( tagger.matchDR()[i] );
      //m_jet_tagged.push_back(tagger.tagResult()[i]);
      //m_jet_matchPID.push_back(tagger.matchPID()[i]);
    }

  }
  m_jet_N = nJets;

  // get photon collection
  Handle<PhotonCollection> photons;
  iEvent.getByToken(m_Tag_Photons,photons);
  const unsigned nPhotons = photons->size();

  // fill photon branches
  //tagger.clearTags();
  //if ( !m_isData && nPhotons ) tagger.tag(nPhotons,&(*photons)[0]); 
  for ( unsigned i=0; i != nPhotons; i++ ) {
    
    const Photon & pho = (*photons)[i];

    m_pho_E.push_back( pho.energy() );
    m_pho_p.push_back( pho.p() );
    m_pho_pt.push_back( pho.pt() );
    m_pho_px.push_back( pho.px() );
    m_pho_py.push_back( pho.py() );
    m_pho_pz.push_back( pho.pz() );
    m_pho_eta.push_back( pho.eta() );
    m_pho_phi.push_back( pho.phi() );

    if ( !m_isData ) {
      //m_pho_matchDR.push_back( tagger.matchDR()[i] );
      //m_pho_tagged.push_back( tagger.tagResult()[i] );
      //m_pho_matchPID.push_back( tagger.matchPID()[i] );
    }

  }
  m_pho_N = nPhotons;

  // get electron collection
  Handle<ElectronCollection> electrons;
  iEvent.getByToken(m_Tag_Electrons,electrons);
  const unsigned nElectrons = electrons->size();

  // fill electron branches
  //tagger.clearTags();
  //if ( !m_isData && nElectrons ) tagger.tag(nElectrons,&(*electrons)[0]);
  for (unsigned i=0; i != nElectrons; i++) {

    const Electron & ele = (*electrons)[i];

    m_ele_E.push_back( ele.energy() );
    m_ele_p.push_back( ele.p() );
    m_ele_pt.push_back( ele.pt() );
    m_ele_px.push_back( ele.px() );
    m_ele_py.push_back( ele.py() );
    m_ele_pz.push_back( ele.pz() );
    m_ele_eta.push_back( ele.eta() );
    m_ele_phi.push_back( ele.phi() );

    if ( !m_isData ) {
      //m_ele_matchDR.push_back( tagger.matchDR()[i] );
      //m_ele_tagged.push_back( tagger.tagResult()[i] );
      //m_ele_matchPID.push_back( tagger.matchPID()[i] );
    }

  }
  m_ele_N = nElectrons;

  // get MET collection
  Handle<std::vector<reco::PFMET> > met;
  iEvent.getByToken(m_Tag_MET,met);

  // fill MET branches
  m_mpt = (*met)[0].sumEt();
  m_mpPhi = (*met)[0].phi();

  // fill generator branches
  /*
  if ( !m_isData ) {

  Mono::MonoTruthSnoop snoopy(iEvent,iSetup,consumesCollector());
  const HepMC::GenParticle *mono = snoopy.mono(Mono::monopole);
  const HepMC::GenParticle *amon = snoopy.mono(Mono::anti_monopole);

  Mono::MonoGenTrackExtrapolator extrap;

  if ( mono ) {
    m_mono_p = chow::mag( mono->momentum().px(), mono->momentum().py(), mono->momentum().pz() );
    m_mono_eta = mono->momentum().eta();
    m_mono_phi = mono->momentum().phi();
    m_mono_m = mono->momentum().m();
    m_mono_px = mono->momentum().px();
    m_mono_py = mono->momentum().py();
    m_mono_pz = mono->momentum().pz();
    m_mono_x = mono->momentum().x();
    m_mono_y = mono->momentum().y();
    m_mono_z = mono->momentum().z();

    extrap.setMonopole(*mono);
    m_monoExp_eta = extrap.etaVr(1.29);
    m_monoExp_phi = extrap.phi();
    m_monoExpEE_eta = extrap.etaVz(3.144);
    m_monoExpEE_phi = extrap.phi();
  }
 
  if ( amon ) { 
    m_amon_p = chow::mag( amon->momentum().px(), amon->momentum().py(), amon->momentum().pz() );
    m_amon_eta = amon->momentum().eta();
    m_amon_phi = amon->momentum().phi();
    m_amon_m = amon->momentum().m(); 
    m_amon_px = amon->momentum().px();
    m_amon_py = amon->momentum().py();
    m_amon_pz = amon->momentum().pz();
    m_amon_x = amon->momentum().x();
    m_amon_y = amon->momentum().y();
    m_amon_z = amon->momentum().z();

    extrap.setMonopole(*amon);
    m_amonExp_eta = extrap.etaVr(1.29);
    m_amonExp_phi = extrap.phi();
  }

  }*/

  //////////////////////////////////////////////////////////
  // Perform track to cluster matching and form monopole candidates
  //
  rematch();

  // fill tree, must go last in this function
  m_tree->Fill();

}

void 
MonoNtupleDumper::FitXY(vector<int> &Group){
  int NumPoints = _Points.size();
  TGraphErrors XYGraph(NumPoints);

  float AvePt = 0;
  for(uint i=0; i<Group.size(); i++){
    edm::Ref<std::vector<reco::Track> > ThisTrack(_hTracks, Group[i]);
    AvePt += ThisTrack->pt() * ThisTrack->charge();
  }
  AvePt /= Group.size();

  //cout << endl;

  float XMax = 0;

  // rotate so the initial path is along the x axis
  float RStart = _Points[0].perp2();
  float REnd = _Points[NumPoints-1].perp2();
  float Phi0;
  if(RStart > REnd) Phi0 = _Points[0].phi();
  else Phi0 = _Points[NumPoints-1].phi();

  for(int i=0; i<NumPoints; i++){
    //cout << "XYFitter: " << Points[i].x() << " " << Points[i].y() << " "
    // << sqrt(Errors[i].cxx()) << " " << sqrt(Errors[i].cyy()) << endl;
    float NewX = _Points[i].x()*cos(Phi0)+_Points[i].y()*sin(Phi0);
    float NewY = -_Points[i].x()*sin(Phi0)+_Points[i].y()*cos(Phi0);
    XYGraph.SetPoint(i, NewX, NewY);
    float ErrorX = sqrt(_Errors[i].cxx()*cos(Phi0)*cos(Phi0) + _Errors[i].cyy()*sin(Phi0)*sin(Phi0) + 2*_Errors[i].cyx()*sin(Phi0)*cos(Phi0));
    float ErrorY = sqrt(_Errors[i].cxx()*sin(Phi0)*sin(Phi0) + _Errors[i].cyy()*cos(Phi0)*cos(Phi0) - 2*_Errors[i].cyx()*sin(Phi0)*cos(Phi0));
    XYGraph.SetPointError(i, ErrorX, ErrorY);
    //cout << "Trans: " << NewX << " " << NewY << " " << ErrorX << " " << ErrorY << endl;
    if(NewX + ErrorX > XMax) XMax = NewX + ErrorX;
  }

  _XYFunc->SetParameters(1, 1, AvePt/0.0114);
  //_XYFunc->SetParLimits(2, -XMax, XMax);
  TFitResultPtr Result = XYGraph.Fit(_XYFunc, "Q S B");

  _XYPar[0] = sqrt(pow(Result->Parameter(0)-Result->Parameter(2),2)+pow(Result->Parameter(1),2)) - fabs(Result->Parameter(2)); // unsigned d0
  _XYErr[0] = Result->ParError(0); // not correct right now
  _XYPar[1] = Phi0 - atan(Result->Parameter(1)/(Result->Parameter(2)-Result->Parameter(0))); // phi0
  _XYErr[1] = Result->ParError(1); // not correct right now
  _XYPar[2] = Result->Parameter(2); // radius
  _XYErr[2] = Result->ParError(2);
  _Chi2XY = Result->Chi2();
  _Ndof = Result->Ndf();

  //cout << _XYPar[0] << " " << _XYPar[1] << " " << _XYPar[2] << endl;
}

void 
MonoNtupleDumper::FitRZ(bool Debug){ /* _RZFitter->ClearPoints();
  int NumPoints = Points.size();
  cout << endl;
  for(int i=0; i<NumPoints; i++){
    double x = sqrt(Points[i].x()*Points[i].x() + Points[i].y()*Points[i].y());
    cout << "RZFitter: " << Points[i].x() << " " << Points[i].y() << " " << Points[i].z() << " "
    << sqrt(Errors[i].cxx()) << " " << sqrt(Errors[i].cyy()) << " " << sqrt(Errors[i].czz()) << endl;
    _RZFitter->AddPoint(&x, Points[i].z(), sqrt(Errors[i].czz()) );
  }
  _RZFitter->Eval();
  for(int i=0; i<3; i++){
    _RZPar[i] = _RZFitter->GetParameter(i);
    _RZErr[i] = _RZFitter->GetParError(i);
  }
  _Chi2RZ = _RZFitter->GetChisquare();
  _NdofRZ = NumPoints - 3;
  if(_NdofRZ <= 0) _NdofRZ = 1; */
  int NumPoints = _Points.size();
  TGraphErrors RZGraph(NumPoints);

  if(Debug) cout << endl;

  for(int i=0; i<NumPoints; i++){
    if(Debug){
      cout << _Points[i].x() << " " << _Points[i].y() << " " << _Points[i].z() << " "
	   << sqrt(_Errors[i].cxx()) << " " << sqrt(_Errors[i].cyy()) << " " << sqrt(_Errors[i].czz()) << endl;
    }
    RZGraph.SetPoint(i, sqrt(_Points[i].x()*_Points[i].x() + _Points[i].y()*_Points[i].y()), _Points[i].z());
    RZGraph.SetPointError(i, sqrt(_Errors[i].rerr(_Points[i])), sqrt(_Errors[i].czz()));
  }

  _RZFunc->SetParameters(0,0,0); //1,-1,0.01);
  TFitResultPtr Result = RZGraph.Fit(_RZFunc, "Q S");

  for(int i=0; i<3; i++){
    _RZPar[i] = Result->Parameter(i);
    _RZErr[i] = Result->ParError(i);
  }
  _Chi2RZ = Result->Chi2();
  //_NdofRZ = Result->Ndf();

}

// ------------ method called once each job just before starting event loop  ------------
void 
MonoNtupleDumper::beginJob()
{
  m_outputFile = new TFile(m_output.c_str(), "recreate");

  //m_avgDir = new TFileDirectory( m_fs->mkdir("avgClusterMaps"));

  m_tree = new TTree("monopoles","Monopole Variables");

  m_tree->Branch("run",&m_run,"run/i");
  m_tree->Branch("lumiBlock",&m_lumi,"lumiBlock/i");
  m_tree->Branch("event",&m_event,"evnet/i");

  m_tree->Branch("NPV",&m_NPV,"NPV/i");

  m_tree->Branch("trigResult",&m_trigResults);
  m_tree->Branch("trigNames",&m_trigNames);

  //track
  m_tree->Branch("Track_Group", &_vGroup);

  m_tree->Branch("Track_XYPar0", &_vXYPar0);
  m_tree->Branch("Track_XYPar1", &_vXYPar1);
  m_tree->Branch("Track_XYPar2", &_vXYPar2);
  m_tree->Branch("Track_XYErr0", &_vXYErr0);
  m_tree->Branch("Track_XYErr1", &_vXYErr1);
  m_tree->Branch("Track_XYErr2", &_vXYErr2);
  m_tree->Branch("Track_RZPar0", &_vRZPar0);
  m_tree->Branch("Track_RZPar1", &_vRZPar1);
  m_tree->Branch("Track_RZPar2", &_vRZPar2);
  m_tree->Branch("Track_RZErr0", &_vRZErr0);
  m_tree->Branch("Track_RZErr1", &_vRZErr1);
  m_tree->Branch("Track_RZErr2", &_vRZErr2);

  m_tree->Branch("Track_Chi2XY", &_vChi2XY);
  m_tree->Branch("Track_Chi2RZ", &_vChi2RZ);
  m_tree->Branch("Track_Ndof", &_vNdof);

  m_tree->Branch("Track_Hits", &_vHits);
  m_tree->Branch("Track_SatHits", &_vSatHits);
  m_tree->Branch("Track_SubHits", &_vSubHits);
  m_tree->Branch("Track_SatSubHits", &_vSatSubHits);
  m_tree->Branch("Track_Iso", &_vIso);

  m_tree->Branch("Track_clustMatchEB",&_clustMatchEB);
  m_tree->Branch("Track_clustDistEB",&_clustDistEB);
  m_tree->Branch("Track_clustMatchEE",&_clustMatchEE);
  m_tree->Branch("Track_clustDistEE",&_clustDistEE);

  m_tree->Branch("Track_clustMatchEBClean",&_clustMatchEBClean);
  m_tree->Branch("Track_clustDistEBClean",&_clustDistEBClean);
  m_tree->Branch("Track_clustMatchEBUnclean",&_clustMatchEBUnclean);
  m_tree->Branch("Track_clustDistEBUnclean",&_clustDistEBUnclean);

  m_tree->Branch("Track_clustMatchEEClean",&_clustMatchEEClean);
  m_tree->Branch("Track_clustDistEEClean",&_clustDistEEClean);
  m_tree->Branch("Track_clustMatchEEUnclean",&_clustMatchEEUnclean);
  m_tree->Branch("Track_clustDistEEUnclean",&_clustDistEEUnclean);

  //trachit candidate
  if(_TrackHitOutput){
    m_tree->Branch("TrackHit_Track", &_vTHTrack);
    m_tree->Branch("TrackHit_X", &_vTHX);
    m_tree->Branch("TrackHit_Y", &_vTHY);
    m_tree->Branch("TrackHit_Z", &_vTHZ);
    m_tree->Branch("TrackHit_ErrX", &_vTHErrX);
    m_tree->Branch("TrackHit_ErrY", &_vTHErrY);
    m_tree->Branch("TrackHit_ErrZ", &_vTHErrZ);
    m_tree->Branch("TrackHit_Strips", &_vTHStrips);
    m_tree->Branch("TrackHit_SatStrips", &_vTHSatStrips);
  }

  // combined candidates
  m_tree->Branch("cand_N",&m_nCandidates,"cand_N/i");
  m_tree->Branch("cand_dist",&m_candDist);
  m_tree->Branch("cand_SubHits",&m_candSubHits);
  m_tree->Branch("cand_SatSubHits",&m_candSatSubHits);
  m_tree->Branch("cand_dEdXSig",&m_canddEdXSig);
  m_tree->Branch("cand_TIso",&m_candTIso);
  m_tree->Branch("cand_f51",&m_candSeedFrac);
  m_tree->Branch("cand_f15",&m_candf15);
  m_tree->Branch("cand_e55",&m_candE55);
  m_tree->Branch("cand_HIso",&m_candHIso);
  m_tree->Branch("cand_XYPar0",&m_candXYPar0);
  m_tree->Branch("cand_XYPar1",&m_candXYPar1);
  m_tree->Branch("cand_XYPar2",&m_candXYPar2);
  m_tree->Branch("cand_RZPar0",&m_candRZPar0);
  m_tree->Branch("cand_RZPar1",&m_candRZPar1);
  m_tree->Branch("cand_RZPar2",&m_candRZPar2);
  m_tree->Branch("cand_eta",&m_candEta);
  m_tree->Branch("cand_phi",&m_candPhi);

  m_tree->Branch("clust_N",&m_nClusters,"clust_N/i");
  m_tree->Branch("clust_E",&m_clust_E);
  m_tree->Branch("clust_eta",&m_clust_eta);
  m_tree->Branch("clust_phi",&m_clust_phi);
  m_tree->Branch("clust_L",&m_clust_L);
  m_tree->Branch("clust_W",&m_clust_W);
  m_tree->Branch("clust_sigEta",&m_clust_sigEta);
  m_tree->Branch("clust_sigPhi",&m_clust_sigPhi);
  m_tree->Branch("clust_skewEta",&m_clust_skewEta);
  m_tree->Branch("clust_skewPhi",&m_clust_skewPhi);
  m_tree->Branch("clust_seedFrac",&m_clust_seedFrac);
  m_tree->Branch("clust_firstFrac",&m_clust_firstFrac);
  m_tree->Branch("clust_secondFrac",&m_clust_secondFrac);
  m_tree->Branch("clust_thirdFrac",&m_clust_thirdFrac);
  m_tree->Branch("clust_matchDR",&m_clust_matchDR);
  m_tree->Branch("clust_matchTime",&m_clust_matchTime);
  m_tree->Branch("clust_matchPt",&m_clust_matchPt);
  m_tree->Branch("clust_matchPID",&m_clust_matchPID);
  m_tree->Branch("clust_tagged",&m_clust_tagged);
  m_tree->Branch("clust_hsE",&m_clust_hsE);
  m_tree->Branch("clust_hsTime",&m_clust_hsTime);
  m_tree->Branch("clust_hsInSeed",&m_clust_hsInSeed);
  m_tree->Branch("clust_hsWeird",&m_clust_hsWeird);
  m_tree->Branch("clust_hsDiWeird",&m_clust_hsDiWeird);
  if(_ClustHitOutput){
    m_tree->Branch("clust_Ecells",&m_clust_Ecells,"clust_Ecells[1500]/D");
    m_tree->Branch("clust_Tcells",&m_clust_Tcells,"clust_Tcells[1500]/D");
  }

  m_tree->Branch("egClust_N",&m_nCleanEgamma,"egClust_N/i");
  m_tree->Branch("egClust_E",&m_egClust_E);
  m_tree->Branch("egClust_size",&m_egClust_size);
  m_tree->Branch("egClust_eta",&m_egClust_eta);
  m_tree->Branch("egClust_phi",&m_egClust_phi);
  m_tree->Branch("egClust_frac51",&m_egClust_frac51);
  m_tree->Branch("egClust_frac15",&m_egClust_frac15);
  m_tree->Branch("egClust_e55",&m_egClust_e55);
  m_tree->Branch("egClust_eMax",&m_egClust_eMax);
  m_tree->Branch("egClust_matchDR",&m_egClust_matchDR);
  m_tree->Branch("egClust_matchPID",&m_egClust_matchPID);
  m_tree->Branch("egClust_tagged",&m_egClust_tagged);
  m_tree->Branch("egClust_hcalIso",&m_egClust_hcalIso);

  m_tree->Branch("egClean_N",&m_nClusterEgamma,"egClean_N/i");
  m_tree->Branch("egClean_E",&m_egClean_E);
  m_tree->Branch("egClean_size",&m_egClean_size);
  m_tree->Branch("egClean_eta",&m_egClean_eta);
  m_tree->Branch("egClean_phi",&m_egClean_phi);
  m_tree->Branch("egClean_frac51",&m_egClean_frac51);
  m_tree->Branch("egClean_frac15",&m_egClean_frac15);
  m_tree->Branch("egClean_e55",&m_egClean_e55);
  m_tree->Branch("egClean_eMax",&m_egClean_eMax);
  m_tree->Branch("egClean_matchDR",&m_egClean_matchDR);
  m_tree->Branch("egClean_matchPID",&m_egClean_matchPID);
  m_tree->Branch("egClean_tagged",&m_egClean_tagged);
  m_tree->Branch("egClean_hcalIso",&m_egClean_hcalIso);

  m_tree->Branch("egComb_N",&m_nCombEgamma,"egComb_N/i");
  m_tree->Branch("egComb_E",&m_egComb_E);
  m_tree->Branch("egComb_size",&m_egComb_size);
  m_tree->Branch("egComb_eta",&m_egComb_eta);
  m_tree->Branch("egComb_phi",&m_egComb_phi);
  m_tree->Branch("egComb_frac51",&m_egComb_frac51);
  m_tree->Branch("egComb_frac15",&m_egComb_frac15);
  m_tree->Branch("egComb_e55",&m_egComb_e55);
  m_tree->Branch("egComb_eMax",&m_egComb_eMax);
  m_tree->Branch("egComb_e25Right",&m_egComb_e25Right);
  m_tree->Branch("egComb_e25Left",&m_egComb_e25Left);
  m_tree->Branch("egComb_matchDR",&m_egComb_matchDR);
  m_tree->Branch("egComb_matchPID",&m_egComb_matchPID);
  m_tree->Branch("egComb_tagged",&m_egComb_tagged);
  m_tree->Branch("egComb_hcalIso",&m_egComb_hcalIso);

  m_tree->Branch("eeClean_N",&m_nCleanEE,"eeClean_N/i");
  m_tree->Branch("eeClean_E",&m_eeClean_E);
  m_tree->Branch("eeClean_size",&m_eeClean_size);
  m_tree->Branch("eeClean_eta",&m_eeClean_eta);
  m_tree->Branch("eeClean_phi",&m_eeClean_phi);
  m_tree->Branch("eeClean_frac51",&m_eeClean_frac51);
  m_tree->Branch("eeClean_frac15",&m_eeClean_frac15);
  m_tree->Branch("eeClean_eMax",&m_eeClean_eMax);
  m_tree->Branch("eeClean_e55",&m_eeClean_e55);
  m_tree->Branch("eeClean_matchDR",&m_eeClean_matchDR);
  m_tree->Branch("eeClean_matchPID",&m_eeClean_matchPID);
  m_tree->Branch("eeClean_tagged",&m_eeClean_tagged);
  m_tree->Branch("eeClean_hcalIso",&m_eeClean_hcalIso);

  m_tree->Branch("eeUnclean_N",&m_nUncleanEE,"eeUnclean_N/i");
  m_tree->Branch("eeUnclean_E",&m_eeUnclean_E);
  m_tree->Branch("eeUnclean_size",&m_eeUnclean_size);
  m_tree->Branch("eeUnclean_eta",&m_eeUnclean_eta);
  m_tree->Branch("eeUnclean_phi",&m_eeUnclean_phi);
  m_tree->Branch("eeUnclean_frac51",&m_eeUnclean_frac51);
  m_tree->Branch("eeUnclean_frac15",&m_eeUnclean_frac15);
  m_tree->Branch("eeUnclean_eMax",&m_eeUnclean_eMax);
  m_tree->Branch("eeUnclean_e55",&m_eeUnclean_e55);
  m_tree->Branch("eeUnclean_matchDR",&m_eeUnclean_matchDR);
  m_tree->Branch("eeUnclean_matchPID",&m_eeUnclean_matchPID);
  m_tree->Branch("eeUnclean_tagged",&m_eeUnclean_tagged);
  m_tree->Branch("eeUnclean_hcalIso",&m_eeUnclean_hcalIso);

  m_tree->Branch("eeComb_N",&m_nCombEE,"eeComb_N/i");
  m_tree->Branch("eeComb_E",&m_eeComb_E);
  m_tree->Branch("eeComb_size",&m_eeComb_size);
  m_tree->Branch("eeComb_eta",&m_eeComb_eta);
  m_tree->Branch("eeComb_phi",&m_eeComb_phi);
  m_tree->Branch("eeComb_frac51",&m_eeComb_frac51);
  m_tree->Branch("eeComb_frac15",&m_eeComb_frac15);
  m_tree->Branch("eeComb_eMax",&m_eeComb_eMax);
  m_tree->Branch("eeComb_e55",&m_eeComb_e55);
  m_tree->Branch("eeComb_e25Left",&m_eeComb_e25Left);
  m_tree->Branch("eeComb_e25Right",&m_eeComb_e25Right);
  m_tree->Branch("eeComb_matchDR",&m_eeComb_matchDR);
  m_tree->Branch("eeComb_matchPID",&m_eeComb_matchPID);
  m_tree->Branch("eeComb_tagged",&m_eeComb_tagged);
  m_tree->Branch("eeComb_hcalIso",&m_eeComb_hcalIso);

  if(_ClustHitOutput){
    m_tree->Branch("ehit_eta",&m_ehit_eta);
    m_tree->Branch("ehit_phi",&m_ehit_phi);
    m_tree->Branch("ehit_time",&m_ehit_time);
    m_tree->Branch("ehit_E",&m_ehit_energy);
    m_tree->Branch("ehit_kWeird",&m_ehit_kWeird);
    m_tree->Branch("ehit_kDiWeird",&m_ehit_kDiWeird);
    m_tree->Branch("ehit_flag",&m_ehit_flag);
  }

  //_Tracker->beginJob(m_tree);

  if(_EleJetPhoOutput){
  m_tree->Branch("jet_N",&m_jet_N,"jet_N/i");
  m_tree->Branch("jet_E",&m_jet_E);
  m_tree->Branch("jet_p",&m_jet_p);
  m_tree->Branch("jet_pt",&m_jet_pt);
  m_tree->Branch("jet_px",&m_jet_px);
  m_tree->Branch("jet_py",&m_jet_py);
  m_tree->Branch("jet_pz",&m_jet_pz);
  m_tree->Branch("jet_eta",&m_jet_eta);
  m_tree->Branch("jet_phi",&m_jet_phi);
  m_tree->Branch("jet_matchDR",&m_jet_matchDR);
  m_tree->Branch("jet_tagged",&m_jet_tagged);
  m_tree->Branch("jet_matchPID",&m_jet_matchPID);

  m_tree->Branch("pho_N",&m_pho_N,"pho_N/i");
  m_tree->Branch("pho_E",&m_pho_E);
  m_tree->Branch("pho_p",&m_pho_p);
  m_tree->Branch("pho_pt",&m_pho_pt);
  m_tree->Branch("pho_px",&m_pho_px);
  m_tree->Branch("pho_py",&m_pho_py);
  m_tree->Branch("pho_pz",&m_pho_pz);
  m_tree->Branch("pho_eta",&m_pho_eta);
  m_tree->Branch("pho_phi",&m_pho_phi);
  m_tree->Branch("pho_matchDR",&m_pho_matchDR);
  m_tree->Branch("pho_tagged",&m_pho_tagged);
  m_tree->Branch("pho_matchPID",&m_pho_matchPID);

  m_tree->Branch("ele_N",&m_ele_N,"ele_N/i");
  m_tree->Branch("ele_E",&m_ele_E);
  m_tree->Branch("ele_p",&m_ele_p);
  m_tree->Branch("ele_pt",&m_ele_pt);
  m_tree->Branch("ele_px",&m_ele_px);
  m_tree->Branch("ele_py",&m_ele_py);
  m_tree->Branch("ele_pz",&m_ele_pz);
  m_tree->Branch("ele_eta",&m_ele_eta);
  m_tree->Branch("ele_phi",&m_ele_phi);
  m_tree->Branch("ele_matchDR",&m_ele_matchDR);
  m_tree->Branch("ele_tagged",&m_ele_tagged);
  m_tree->Branch("ele_matchPID",&m_ele_matchPID);
  }

  m_tree->Branch("mpt_pt",&m_mpt,"mpt_pt/D");
  m_tree->Branch("mpt_phi",&m_mpPhi,"mpt_phi/D");


  if ( !m_isData ) {
  m_tree->Branch("mono_p", &m_mono_p, "mono_p/D");
  m_tree->Branch("mono_eta", &m_mono_eta, "mono_eta/D");
  m_tree->Branch("mono_phi", &m_mono_phi, "mono_phi/D");
  m_tree->Branch("mono_m", &m_mono_m, "mono_m/D");
  m_tree->Branch("mono_px",&m_mono_px, "mono_px/D");
  m_tree->Branch("mono_py",&m_mono_py, "mono_py/D");
  m_tree->Branch("mono_pz",&m_mono_pz, "mono_pz/D");
  m_tree->Branch("mono_x",&m_mono_x, "mono_x/D");
  m_tree->Branch("mono_y",&m_mono_y, "mono_y/D");
  m_tree->Branch("mono_z",&m_mono_z, "mono_z/D");
  
  m_tree->Branch("monoExp_eta",&m_monoExp_eta, "monoExp_eta/D");
  m_tree->Branch("monoExp_phi",&m_monoExp_phi, "monoExp_phi/D");

  m_tree->Branch("amon_p", &m_amon_p, "amon_p/D");
  m_tree->Branch("amon_eta", &m_amon_eta, "amon_eta/D");
  m_tree->Branch("amon_phi", &m_amon_phi, "amon_phi/D");
  m_tree->Branch("amon_m", &m_amon_m, "amon_m/D");
  m_tree->Branch("amon_px",&m_amon_px, "amon_px/D");
  m_tree->Branch("amon_py",&m_amon_py, "amon_py/D");
  m_tree->Branch("amon_pz",&m_amon_pz, "amon_pz/D");
  m_tree->Branch("amon_x",&m_amon_x, "amon_x/D");
  m_tree->Branch("amon_y",&m_amon_y, "amon_y/D");
  m_tree->Branch("amon_z",&m_amon_z, "amon_z/D");

  m_tree->Branch("amonExp_eta",&m_amonExp_eta, "amonExp_eta/D");
  m_tree->Branch("amonExp_phi",&m_amonExp_phi, "amonExp_phi/D");
  }

}

// ------------ method called once each job just after ending the event loop  ------------
void 
MonoNtupleDumper::endJob() 
{
  m_outputFile->cd();
  m_tree->Write();

  for(std::map<Mono::ClustCategorizer,TH2D*>::iterator i = m_clustEMap.begin(); i != m_clustEMap.end(); i++)
  {
    i->second->Write();
  }
  for(std::map<Mono::ClustCategorizer,TH2D*>::iterator i = m_clustTMap.begin(); i != m_clustTMap.end(); i++)
  {
    i->second->Write();
  }

  //_Tracker->endJob();

  m_outputFile->Close();
}

// ------------ method called when starting to processes a run  ------------
void 
MonoNtupleDumper::beginRun(edm::Run const&, edm::EventSetup const&)
{
}



void MonoNtupleDumper::clear()
{ 


     m_run = 0;
     m_lumi = 0;
     m_event = 0;
  
    m_NPV = 0;

    m_nClusters = 0;
    m_clust_E.clear();
    m_clust_eta.clear();
    m_clust_phi.clear();
    m_clust_L.clear();
    m_clust_W.clear();
    m_clust_sigEta.clear();
    m_clust_sigPhi.clear();
    m_clust_skewEta.clear();
    m_clust_skewPhi.clear();
    m_clust_seedFrac.clear();
    m_clust_firstFrac.clear();
    m_clust_secondFrac.clear();
    m_clust_thirdFrac.clear();
    m_clust_matchDR.clear();
    m_clust_matchTime.clear();
    m_clust_matchPt.clear();
    m_clust_matchPID.clear();
    m_clust_tagged.clear();
    m_clust_hsE.clear();
    m_clust_hsTime.clear();
    m_clust_hsInSeed.clear();
    m_clust_hsWeird.clear();
    m_clust_hsDiWeird.clear();
    for ( unsigned i=0; i != SS; i++ ){
      m_clust_Ecells[i] = -999.;
      m_clust_Tcells[i] = -999.;
    }


    m_nClusterEgamma = 0;
    m_egClust_E.clear();
    m_egClust_size.clear();
    m_egClust_eta.clear();
    m_egClust_phi.clear();
    m_egClust_frac51.clear();
    m_egClust_frac15.clear();
    m_egClust_e55.clear();
    m_egClust_eMax.clear();
    m_egClust_matchDR.clear();
    m_egClust_matchPID.clear();
    m_egClust_tagged.clear();
    m_egClust_hcalIso.clear();

    m_nCleanEgamma = 0;
    m_egClean_E.clear();
    m_egClean_size.clear();
    m_egClean_eta.clear();
    m_egClean_phi.clear();
    m_egClean_frac51.clear();
    m_egClean_frac15.clear();
    m_egClean_e55.clear();
    m_egClean_eMax.clear();
    m_egClean_matchDR.clear();
    m_egClean_matchPID.clear();
    m_egClean_tagged.clear();
    m_egClean_hcalIso.clear();

    m_nCombEgamma = 0;
    m_egComb_E.clear();
    m_egComb_size.clear();
    m_egComb_eta.clear();
    m_egComb_phi.clear();
    m_egComb_frac51.clear();
    m_egComb_frac15.clear();
    m_egComb_e55.clear();
    m_egComb_eMax.clear();
    m_egComb_e25Right.clear();
    m_egComb_e25Left.clear();
    m_egComb_matchDR.clear();
    m_egComb_matchPID.clear();
    m_egComb_tagged.clear();
    m_egComb_hcalIso.clear();

    m_nCleanEE = 0;
    m_eeClean_E.clear();
    m_eeClean_size.clear();
    m_eeClean_eta.clear();
    m_eeClean_phi.clear();
    m_eeClean_frac51.clear();
    m_eeClean_frac15.clear();
    m_eeClean_eMax.clear();
    m_eeClean_e55.clear();
    m_eeClean_matchDR.clear();
    m_eeClean_matchPID.clear();
    m_eeClean_tagged.clear();
    m_eeClean_hcalIso.clear();

    m_nUncleanEE = 0;
    m_eeUnclean_E.clear();
    m_eeUnclean_size.clear();
    m_eeUnclean_eta.clear();
    m_eeUnclean_phi.clear();
    m_eeUnclean_frac51.clear();
    m_eeUnclean_frac15.clear();
    m_eeUnclean_eMax.clear();
    m_eeUnclean_e55.clear();
    m_eeUnclean_matchDR.clear();
    m_eeUnclean_matchPID.clear();
    m_eeUnclean_tagged.clear();
    m_eeUnclean_hcalIso.clear();

    m_nCombEE = 0;
    m_eeComb_E.clear();
    m_eeComb_size.clear();
    m_eeComb_eta.clear();
    m_eeComb_phi.clear();
    m_eeComb_frac51.clear();
    m_eeComb_frac15.clear();
    m_eeComb_eMax.clear();
    m_eeComb_e55.clear();
    m_eeComb_e25Left.clear();
    m_eeComb_e25Right.clear();
    m_eeComb_matchDR.clear();
    m_eeComb_matchPID.clear();
    m_eeComb_tagged.clear();
    m_eeComb_hcalIso.clear();

    // Ecal RecHits
    m_ehit_eta.clear();
    m_ehit_phi.clear();
    m_ehit_time.clear();
    m_ehit_energy.clear();
    m_ehit_otEnergy.clear();
    m_ehit_kWeird.clear();
    m_ehit_kDiWeird.clear();
    m_ehit_flag.clear();

    // Jet information
    m_jet_N = 0;
    m_jet_E.clear();
    m_jet_p.clear();
    m_jet_pt.clear();
    m_jet_px.clear();
    m_jet_py.clear();
    m_jet_pz.clear();
    m_jet_eta.clear();
    m_jet_phi.clear();
    m_jet_matchDR.clear();
    m_jet_tagged.clear();
    m_jet_matchPID.clear();


    // Photon information
    m_pho_N = 0;
    m_pho_E.clear();
    m_pho_p.clear();
    m_pho_pt.clear();
    m_pho_px.clear();
    m_pho_py.clear();
    m_pho_pz.clear();
    m_pho_eta.clear();
    m_pho_phi.clear();

    // Electron information
    m_ele_N = 0;
    m_ele_E.clear();
    m_ele_p.clear();
    m_ele_pt.clear();
    m_ele_px.clear();
    m_ele_py.clear();
    m_ele_pz.clear();
    m_ele_eta.clear();
    m_ele_phi.clear();

    m_mpt = 0.;
    m_mpPhi = 0.;

  m_mono_p = 0.;
  m_mono_eta = 0.;
  m_mono_phi = 0.;
  m_mono_m = 0.;
  m_mono_px = 0.;
  m_mono_py = 0.;
  m_mono_pz = 0.;
  m_mono_x = 0.;
  m_mono_y = 0.;
  m_mono_z = 0.;

  m_monoExp_eta = 0.;
  m_monoExp_phi = 0.;

  m_amon_p = 0.;
  m_amon_eta = 0.;
  m_amon_phi = 0.;
  m_amon_m = 0.;
  m_amon_px = 0.;
  m_amon_py = 0.;
  m_amon_pz = 0.;
  m_amon_x = 0.;
  m_amon_y = 0.;
  m_amon_z = 0.;

  m_amonExp_eta = 0.;
  m_amonExp_phi = 0.;

  // combined candidates
  m_nCandidates = 0U;
  m_candDist.clear();
  m_candSubHits.clear();
  m_candSatSubHits.clear();
  m_canddEdXSig.clear();
  m_candTIso.clear();
  m_candSeedFrac.clear();
  m_candf15.clear();
  m_candE55.clear();
  m_candHIso.clear();
  m_candXYPar0.clear();
  m_candXYPar1.clear();
  m_candXYPar2.clear();
  m_candRZPar0.clear();
  m_candRZPar1.clear();
  m_candRZPar2.clear();
  m_candEta.clear();
  m_candPhi.clear();

}

void MonoNtupleDumper::rematch()
{
  /*

  const double EcalR = 129.0;

  // Get a handle on the monopole tracks
  std::vector<Mono::MonoTrack> tracks;
  _Tracker->getTracks(tracks);

  const std::vector<int> & subHits = _Tracker->getSubHits();
  const std::vector<int> & satSubHits = _Tracker->getSatSubHits();
  const std::vector<float> & tIso = _Tracker->getTIso();
  const std::vector<float> & nDof = _Tracker->getNdof();

  const unsigned nTracks = tracks.size();

  for(unsigned i=0; i < nTracks; i++){

    // if Ndof <= 3 continue
    if ( nDof[i] <= 3 ) continue;

    const Mono::MonoTrack & tr = tracks[i];

    // Calculate expected Eta, Phi for ECAL cluster
    float ThisZ = tr.rzp0() + EcalR*tr.rzp1() + EcalR*EcalR*tr.rzp2();
    float ThisEta = TMath::ASinH(ThisZ / EcalR);
    float ThisPhi = tr.xyp1() - TMath::ASin((EcalR*EcalR-tr.xyp0()*tr.xyp2())/(2*EcalR*(tr.xyp2()-tr.xyp0())));

    float MinDR = 999;
    int BestEBCluster=-1, BestEECluster=-1;
    const unsigned nEBclusters = m_nCombEgamma;
    for(unsigned j=0; j < nEBclusters; j++){
      float DEta = ThisEta-m_egComb_eta[j];
      float DPhi = ThisPhi-m_egComb_phi[j];
      while(DPhi < -3.14159) DPhi += 2*3.14159;
      while(DPhi >  3.14159) DPhi -= 2*3.14159;

      float ThisDR = sqrt(pow(DEta,2) + pow(DPhi,2));
      if(ThisDR < MinDR){
        MinDR = ThisDR;
        BestEBCluster = j;
      }
    }

    const unsigned nEEclusters = m_nCombEE;
    for(unsigned j=0; j < nEEclusters; j++){
      float DEta = ThisEta-m_eeComb_eta[j];
      float DPhi = ThisPhi-m_eeComb_phi[j];
      while(DPhi < -3.14159) DPhi += 2*3.14159;
      while(DPhi >  3.14159) DPhi -= 2*3.14159;

      float ThisDR = sqrt(pow(DEta,2) + pow(DPhi,2));
      if(ThisDR < MinDR){
        MinDR = ThisDR;
        BestEECluster = j;
        BestEBCluster = -1;
      }
    }

    // fill place holders of matches
    int matchEB = BestEBCluster;
    int matchEE = BestEECluster;
    double distEB = BestEBCluster >= 0 ? MinDR : 999;
    double distEE = BestEECluster >= 0 ? MinDR : 999;

    // continue to next track if match = -1
    if ( matchEB == -1 && matchEE == -1 ) continue;

    // calculate dE/dX significance
    const double dEdXSig = sqrt(-TMath::Log(TMath::BinomialI(0.07, subHits[i], satSubHits[i])));
 
    /////////////////////////////////////////
    // assign values to branches
    m_nCandidates++;
    m_candSubHits.push_back( subHits[i] );
    m_candSatSubHits.push_back( satSubHits[i] );
    m_canddEdXSig.push_back( dEdXSig );
    m_candTIso.push_back( tIso[i] );
    m_candXYPar0.push_back( tr.xyp0() );
    m_candXYPar1.push_back( tr.xyp1() );
    m_candXYPar2.push_back( tr.xyp2() );
    m_candRZPar0.push_back( tr.rzp0() );
    m_candRZPar1.push_back( tr.rzp1() );
    m_candRZPar2.push_back( tr.rzp2() );

    if ( distEB < distEE ) {
      m_candDist.push_back( distEB );
      m_candSeedFrac.push_back( m_egComb_frac51[matchEB] );
      m_candf15.push_back( m_egComb_frac15[matchEB] );
      m_candE55.push_back( m_egComb_e55[matchEB] );
      m_candHIso.push_back( m_egComb_hcalIso[matchEB] );
      m_candEta.push_back( m_egComb_eta[matchEB] );
      m_candPhi.push_back( m_egComb_phi[matchEB] );
    } else {
      m_candDist.push_back( distEE );
      m_candSeedFrac.push_back( m_eeComb_frac51[matchEE] );
      m_candf15.push_back( m_eeComb_frac15[matchEE] );
      m_candE55.push_back( m_eeComb_e55[matchEE] );
      m_candHIso.push_back( m_eeComb_hcalIso[matchEE] );
      m_candEta.push_back( m_eeComb_eta[matchEE] );
      m_candPhi.push_back( m_eeComb_phi[matchEE] );
    }

 }
  */
}



// ------------ method called when ending the processing of a run  ------------
void 
MonoNtupleDumper::endRun(edm::Run const&, edm::EventSetup const&)
{
  //m_ecalCalib.calculateHij();
  //m_ecalCalib.dumpCalibration();

  std::map<Mono::ClustCategorizer,unsigned>::iterator counts = m_clustCatCount.begin();
  std::map<Mono::ClustCategorizer,unsigned>::iterator end = m_clustCatCount.end();
  for ( ; counts != end; counts++ ) {
    const Mono::ClustCategorizer & cat = counts->first;
    unsigned & count = counts->second;
    m_clustEMap[cat]->Scale(1.0/count);  
    m_clustTMap[cat]->Scale(1.0/count);
  }

}

// ------------ method called when starting to processes a luminosity block  ------------
void 
MonoNtupleDumper::beginLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}

// ------------ method called when ending the processing of a luminosity block  ------------
void 
MonoNtupleDumper::endLuminosityBlock(edm::LuminosityBlock const&, edm::EventSetup const&)
{
}

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void
MonoNtupleDumper::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(MonoNtupleDumper);
